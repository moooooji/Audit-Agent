{
  "WBERA.name": [
    "function name() public pure override returns (string memory) {\n        return \"Wrapped Bera\";\n    }"
  ],
  "WBERA.symbol": [
    "function symbol() public pure override returns (string memory) {\n        return \"WBERA\";\n    }"
  ],
  "RewardVault_V4.initialize": [
    "function initialize(\n        address _beaconDepositContract,\n        address _bgt,\n        address _distributor,\n        address _stakingToken\n    )\n        external\n        initializer\n    {\n        __FactoryOwnable_init(msg.sender);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __StakingRewards_init(_stakingToken, _bgt, 3 days);\n        maxIncentiveTokensCount = 3;\n        distributor = _distributor;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        emit DistributorSet(_distributor);\n        emit MaxIncentiveTokensCountUpdated(maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault_V4.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) NotDistributor.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V4.onlyOperatorOrUser": [
    "modifier onlyOperatorOrUser(address account) {\n        if (msg.sender != account) {\n            if (msg.sender != _operators[account]) NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "RewardVault_V4.checkSelfStakedBalance": [
    "modifier checkSelfStakedBalance(address account, uint256 amount) {\n        _checkSelfStakedBalance(account, amount);\n        _;\n    }"
  ],
  "RewardVault_V4.onlyWhitelistedToken": [
    "modifier onlyWhitelistedToken(address token) {\n        if (incentives[token].minIncentiveRate == 0) TokenNotWhitelisted.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V4.setDistributor": [
    "function setDistributor(address _rewardDistribution) external onlyFactoryOwner {\n        if (_rewardDistribution == address(0)) ZeroAddress.selector.revertWith();\n        distributor = _rewardDistribution;\n        emit DistributorSet(_rewardDistribution);\n    }"
  ],
  "RewardVault_V4.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external onlyDistributor {\n        _notifyRewardAmount(reward);\n        _processIncentives(pubkey, reward);\n    }"
  ],
  "RewardVault_V4.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyFactoryOwner {\n        if (tokenAddress == address(stakeToken)) CannotRecoverStakingToken.selector.revertWith();\n        if (incentives[tokenAddress].minIncentiveRate != 0) CannotRecoverIncentiveToken.selector.revertWith();\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }"
  ],
  "RewardVault_V4.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external onlyFactoryOwner {\n        _setRewardsDuration(_rewardsDuration);\n    }"
  ],
  "RewardVault_V4.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(\n        address token,\n        uint256 minIncentiveRate,\n        address manager\n    )\n        external\n        onlyFactoryOwner\n    {\n        if (minIncentiveRate == 0) MinIncentiveRateIsZero.selector.revertWith();\n        if (minIncentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        if (token == address(0) || manager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        if (whitelistedTokens.length == maxIncentiveTokensCount || incentive.minIncentiveRate != 0) {\n            TokenAlreadyWhitelistedOrLimitReached.selector.revertWith();\n        }\n        whitelistedTokens.push(token);\n        incentive.incentiveRate = minIncentiveRate;\n        incentive.minIncentiveRate = minIncentiveRate;\n        incentive.manager = manager;\n        emit IncentiveTokenWhitelisted(token, minIncentiveRate, manager);\n    }"
  ],
  "RewardVault_V4.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external onlyFactoryVaultManager onlyWhitelistedToken(token) {\n        delete incentives[token];\n        _deleteWhitelistedTokenFromList(token);\n        emit IncentiveTokenRemoved(token);\n    }"
  ],
  "RewardVault_V4.updateIncentiveManager": [
    "function updateIncentiveManager(\n        address token,\n        address newManager\n    )\n        external\n        onlyFactoryOwner\n        onlyWhitelistedToken(token)\n    {\n        if (newManager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        address currentManager = incentive.manager;\n        incentive.manager = newManager;\n        emit IncentiveManagerChanged(token, newManager, currentManager);\n    }"
  ],
  "RewardVault_V4.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external onlyFactoryOwner {\n        if (_maxIncentiveTokensCount < whitelistedTokens.length) {\n            InvalidMaxIncentiveTokensCount.selector.revertWith();\n        }\n        maxIncentiveTokensCount = _maxIncentiveTokensCount;\n        emit MaxIncentiveTokensCountUpdated(_maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault_V4.pause": [
    "function pause() external onlyFactoryVaultPauser {\n        _pause();\n    }"
  ],
  "RewardVault_V4.unpause": [
    "function unpause() external onlyFactoryVaultManager {\n        _unpause();\n    }"
  ],
  "RewardVault_V4.operator": [
    "function operator(address account) external view returns (address) {\n        return _operators[account];\n    }"
  ],
  "RewardVault_V4.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256) {\n        return whitelistedTokens.length;\n    }"
  ],
  "RewardVault_V4.getWhitelistedTokens": [
    "function getWhitelistedTokens() public view returns (address[] memory) {\n        return whitelistedTokens;\n    }"
  ],
  "RewardVault_V4.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256) {\n        return _delegateStake[account].delegateTotalStaked;\n    }"
  ],
  "RewardVault_V4.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256) {\n        return _delegateStake[account].stakedByDelegate[delegate];\n    }"
  ],
  "RewardVault_V4.stake": [
    "function stake(uint256 amount) external nonReentrant whenNotPaused {\n        _stake(msg.sender, amount);\n    }"
  ],
  "RewardVault_V4.delegateStake": [
    "function delegateStake(address account, uint256 amount) external nonReentrant whenNotPaused {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        _stake(account, amount);\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            info.delegateTotalStaked += amount;\n            info.stakedByDelegate[msg.sender] += amount;\n        }\n        emit DelegateStaked(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V4.withdraw": [
    "function withdraw(uint256 amount) external nonReentrant checkSelfStakedBalance(msg.sender, amount) {\n        _withdraw(msg.sender, amount);\n    }"
  ],
  "RewardVault_V4.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external nonReentrant {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            uint256 stakedByDelegate = info.stakedByDelegate[msg.sender];\n            if (stakedByDelegate < amount) InsufficientDelegateStake.selector.revertWith();\n            info.stakedByDelegate[msg.sender] = stakedByDelegate - amount;\n            info.delegateTotalStaked -= amount;\n        }\n        _withdraw(account, amount);\n        emit DelegateWithdrawn(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V4.getReward": [
    "function getReward(\n        address account,\n        address recipient\n    )\n        external\n        nonReentrant\n        onlyOperatorOrUser(account)\n        returns (uint256)\n    {\n        return _getReward(account, recipient);\n    }"
  ],
  "RewardVault_V4.exit": [
    "function exit(address recipient) external nonReentrant {\n        uint256 amount = _accountInfo[msg.sender].balance - _delegateStake[msg.sender].delegateTotalStaked;\n        _withdraw(msg.sender, amount);\n        _getReward(msg.sender, recipient);\n    }"
  ],
  "RewardVault_V4.setOperator": [
    "function setOperator(address _operator) external {\n        _operators[msg.sender] = _operator;\n        emit OperatorSet(msg.sender, _operator);\n    }"
  ],
  "RewardVault_V4.addIncentive": [
    "function addIncentive(\n        address token,\n        uint256 amount,\n        uint256 incentiveRate\n    )\n        external\n        nonReentrant\n        onlyWhitelistedToken(token)\n    {\n        if (incentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        if (incentiveRate < minIncentiveRate) InvalidIncentiveRate.selector.revertWith();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        incentive.amountRemaining = amountRemainingBefore + amount;\n        if (amountRemainingBefore == 0) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else if (incentiveRate >= incentiveRateStored) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else {\n            InvalidIncentiveRate.selector.revertWith();\n        }\n        emit IncentiveAdded(token, msg.sender, amount, incentive.incentiveRate);\n    }"
  ],
  "RewardVault_V4.accountIncentives": [
    "function accountIncentives(address token, uint256 amount) external nonReentrant onlyWhitelistedToken(token) {\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        uint256 incentiveBalance = IERC20(token).balanceOf(address(this));\n        if (amount > incentiveBalance - amountRemainingBefore) NotEnoughBalance.selector.revertWith();\n        incentive.amountRemaining += amount;\n        emit IncentiveAdded(token, msg.sender, amount, incentiveRateStored);\n    }"
  ],
  "RewardVault_V4._checkSelfStakedBalance": [
    "function _checkSelfStakedBalance(address account, uint256 amount) internal view {\n        unchecked {\n            uint256 selfStaked = _accountInfo[account].balance - _delegateStake[account].delegateTotalStaked;\n            if (selfStaked < amount) InsufficientSelfStake.selector.revertWith();\n        }\n    }"
  ],
  "RewardVault_V4._safeTransferRewardToken": [
    "function _safeTransferRewardToken(address to, uint256 amount) internal override {\n        rewardToken.safeTransferFrom(distributor, to, amount);\n    }"
  ],
  "RewardVault_V4._checkRewardSolvency": [
    "function _checkRewardSolvency() internal view override {\n        uint256 allowance = rewardToken.allowance(distributor, address(this));\n        if (undistributedRewards / PRECISION > allowance) InsolventReward.selector.revertWith();\n    }"
  ],
  "RewardVault_V4._processIncentives": [
    "function _processIncentives(bytes calldata pubkey, uint256 bgtEmitted) internal {\n        address _operator = beaconDepositContract.getOperator(pubkey);\n        IBeraChef beraChef = IDistributor(distributor).beraChef();\n        address bgtIncentiveDistributor = getBGTIncentiveDistributor();\n        uint256 whitelistedTokensCount = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < whitelistedTokensCount; ++i) {\n                address token = whitelistedTokens[i];\n                Incentive storage incentive = incentives[token];\n                uint256 amount = FixedPointMathLib.mulDiv(bgtEmitted, incentive.incentiveRate, PRECISION);\n                uint256 amountRemaining = incentive.amountRemaining;\n                amount = FixedPointMathLib.min(amount, amountRemaining);\n                uint256 validatorShare;\n                if (amount > 0) {\n                    validatorShare = beraChef.getValidatorIncentiveTokenShare(pubkey, amount);\n                    amount -= validatorShare;\n                }\n                if (validatorShare > 0) {\n                    bool success = token.trySafeTransfer(_operator, validatorShare);\n                    if (success) {\n                        amountRemaining -= validatorShare;\n                        emit IncentivesProcessed(pubkey, token, bgtEmitted, validatorShare);\n                    } else {\n                        emit IncentivesProcessFailed(pubkey, token, bgtEmitted, validatorShare);\n                    }\n                }\n                if (amount > 0) {\n                    bytes memory data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, amount));\n                    (bool success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                    if (success) {\n                        data = abi.encodeCall(IBGTIncentiveDistributor.receiveIncentive, (pubkey, token, amount));\n                        (success,) = bgtIncentiveDistributor.call{ gas: SAFE_GAS_LIMIT }(data);\n                        if (success) {\n                            amountRemaining -= amount;\n                            emit BGTBoosterIncentivesProcessed(pubkey, token, bgtEmitted, amount);\n                        } else {\n                            data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, 0));\n                            (success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                            emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                        }\n                    }\n                    else {\n                        emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                    }\n                }\n                incentive.amountRemaining = amountRemaining;\n            }\n        }\n    }"
  ],
  "RewardVault_V4._deleteWhitelistedTokenFromList": [
    "function _deleteWhitelistedTokenFromList(address token) internal {\n        uint256 activeTokens = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < activeTokens; ++i) {\n                if (token == whitelistedTokens[i]) {\n                    whitelistedTokens[i] = whitelistedTokens[activeTokens - 1];\n                    whitelistedTokens.pop();\n                    return;\n                }\n            }\n        }\n    }"
  ],
  "BeaconRootsHelper.setZeroValidatorPubkeyGIndex": [
    "function setZeroValidatorPubkeyGIndex(uint64 _zeroValidatorPubkeyGIndex) public virtual {\n        zeroValidatorPubkeyGIndex = _zeroValidatorPubkeyGIndex;\n        emit ZeroValidatorPubkeyGIndexChanged(_zeroValidatorPubkeyGIndex);\n    }"
  ],
  "BeaconRootsHelper.setProposerIndexGIndex": [
    "function setProposerIndexGIndex(uint64 _proposerIndexGIndex) public virtual {\n        proposerIndexGIndex = _proposerIndexGIndex;\n        emit ProposerIndexGIndexChanged(_proposerIndexGIndex);\n    }"
  ],
  "BeaconRootsHelper.isTimestampActionable": [
    "function isTimestampActionable(uint64 timestamp) external view returns (bool) {\n        if (!timestamp.isParentBlockRootAt()) return false;\n        uint64 timestampIndex = timestamp % HISTORY_BUFFER_LENGTH;\n        return _processedTimestampsBuffer[timestampIndex] != timestamp;\n    }"
  ],
  "BeaconRootsHelper._processTimestampInBuffer": [
    "function _processTimestampInBuffer(uint64 timestamp) internal returns (bytes32 parentBeaconBlockRoot) {\n        parentBeaconBlockRoot = timestamp.getParentBlockRootAt();\n        uint64 timestampIndex = timestamp % HISTORY_BUFFER_LENGTH;\n        if (timestamp == _processedTimestampsBuffer[timestampIndex]) TimestampAlreadyProcessed.selector.revertWith();\n        _processedTimestampsBuffer[timestampIndex] = timestamp;\n        emit TimestampProcessed(timestamp);\n    }"
  ],
  "BeaconRootsHelper._verifyProposerIndexInBeaconBlock": [
    "function _verifyProposerIndexInBeaconBlock(\n        bytes32 beaconBlockRoot,\n        bytes32[] calldata proposerIndexProof,\n        uint64 proposerIndex\n    )\n        internal\n        view\n    {\n        bytes32 proposerIndexRoot = SSZ.uint64HashTreeRoot(proposerIndex);\n        if (!SSZ.verifyProof(proposerIndexProof, beaconBlockRoot, proposerIndexRoot, proposerIndexGIndex)) {\n            InvalidProof.selector.revertWith();\n        }\n    }"
  ],
  "BeaconRootsHelper._verifyValidatorPubkeyInBeaconBlock": [
    "function _verifyValidatorPubkeyInBeaconBlock(\n        bytes32 beaconBlockRoot,\n        bytes32[] calldata validatorPubkeyProof,\n        bytes calldata validatorPubkey,\n        uint64 validatorIndex\n    )\n        internal\n        view\n    {\n        if (validatorIndex >= VALIDATOR_REGISTRY_LIMIT) {\n            IndexOutOfRange.selector.revertWith();\n        }\n        bytes32 validatorPubkeyRoot = SSZ.validatorPubkeyHashTreeRoot(validatorPubkey);\n        uint256 gIndex = zeroValidatorPubkeyGIndex + (VALIDATOR_PUBKEY_OFFSET * validatorIndex);\n        if (!SSZ.verifyProof(validatorPubkeyProof, beaconBlockRoot, validatorPubkeyRoot, gIndex)) {\n            InvalidProof.selector.revertWith();\n        }\n    }"
  ],
  "FeeCollector.initialize": [
    "function initialize(\n        address governance,\n        address _payoutToken,\n        address _rewardReceiver,\n        uint256 _payoutAmount\n    )\n        external\n        initializer\n    {\n        __AccessControl_init();\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n        if (governance == address(0) || _payoutToken == address(0) || _rewardReceiver == address(0)) {\n            ZeroAddress.selector.revertWith();\n        }\n        if (_payoutAmount == 0) PayoutAmountIsZero.selector.revertWith();\n        _grantRole(DEFAULT_ADMIN_ROLE, governance);\n        _setRoleAdmin(PAUSER_ROLE, MANAGER_ROLE);\n        payoutToken = _payoutToken;\n        payoutAmount = _payoutAmount;\n        rewardReceiver = _rewardReceiver;\n        emit PayoutAmountSet(0, _payoutAmount);\n    }"
  ],
  "FeeCollector._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "FeeCollector.queuePayoutAmountChange": [
    "function queuePayoutAmountChange(uint256 _newPayoutAmount) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newPayoutAmount == 0) PayoutAmountIsZero.selector.revertWith();\n        emit QueuedPayoutAmount(_newPayoutAmount, payoutAmount);\n        queuedPayoutAmount = _newPayoutAmount;\n    }"
  ],
  "FeeCollector.claimFees": [
    "function claimFees(address _recipient, address[] calldata _feeTokens) external whenNotPaused {\n        IERC20(payoutToken).safeTransferFrom(msg.sender, rewardReceiver, payoutAmount);\n        BGTStaker(rewardReceiver).notifyRewardAmount(payoutAmount);\n        for (uint256 i; i < _feeTokens.length;) {\n            address feeToken = _feeTokens[i];\n            uint256 feeTokenAmountToTransfer = IERC20(feeToken).balanceOf(address(this));\n            IERC20(feeToken).safeTransfer(_recipient, feeTokenAmountToTransfer);\n            emit FeesClaimed(msg.sender, _recipient, feeToken, feeTokenAmountToTransfer);\n            unchecked {\n                ++i;\n            }\n        }\n        emit FeesClaimed(msg.sender, _recipient);\n        if (queuedPayoutAmount != 0) _setPayoutAmount();\n    }"
  ],
  "FeeCollector.donate": [
    "function donate(uint256 amount) external whenNotPaused {\n        if (amount < payoutAmount) DonateAmountLessThanPayoutAmount.selector.revertWith();\n        IERC20(payoutToken).safeTransferFrom(msg.sender, rewardReceiver, amount);\n        BGTStaker(rewardReceiver).notifyRewardAmount(amount);\n        emit PayoutDonated(msg.sender, amount);\n    }"
  ],
  "FeeCollector.pause": [
    "function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }"
  ],
  "FeeCollector.unpause": [
    "function unpause() external onlyRole(MANAGER_ROLE) {\n        _unpause();\n    }"
  ],
  "FeeCollector._setPayoutAmount": [
    "function _setPayoutAmount() internal {\n        emit PayoutAmountSet(payoutAmount, queuedPayoutAmount);\n        payoutAmount = queuedPayoutAmount;\n        queuedPayoutAmount = 0;\n    }"
  ],
  "BGTStaker.initialize": [
    "function initialize(\n        address _bgt,\n        address _feeCollector,\n        address _governance,\n        address _rewardToken\n    )\n        external\n        initializer\n    {\n        __Ownable_init(_governance);\n        __StakingRewards_init(_bgt, _rewardToken, 7 days);\n        __UUPSUpgradeable_init();\n        FEE_COLLECTOR = _feeCollector;\n    }"
  ],
  "BGTStaker.onlyBGT": [
    "modifier onlyBGT() {\n        if (msg.sender != address(stakeToken)) NotBGT.selector.revertWith();\n        _;\n    }"
  ],
  "BGTStaker.onlyFeeCollector": [
    "modifier onlyFeeCollector() {\n        if (msg.sender != FEE_COLLECTOR) NotFeeCollector.selector.revertWith();\n        _;\n    }"
  ],
  "BGTStaker._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }"
  ],
  "BGTStaker.notifyRewardAmount": [
    "function notifyRewardAmount(uint256 reward) external onlyFeeCollector {\n        _notifyRewardAmount(reward);\n    }"
  ],
  "BGTStaker.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        if (tokenAddress == address(rewardToken)) CannotRecoverRewardToken.selector.revertWith();\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }"
  ],
  "BGTStaker.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        _setRewardsDuration(_rewardsDuration);\n    }"
  ],
  "BGTStaker.stake": [
    "function stake(address account, uint256 amount) external onlyBGT {\n        _stake(account, amount);\n    }"
  ],
  "BGTStaker.withdraw": [
    "function withdraw(address account, uint256 amount) external onlyBGT {\n        _withdraw(account, amount);\n    }"
  ],
  "BGTStaker.getReward": [
    "function getReward() external returns (uint256) {\n        return _getReward(msg.sender, msg.sender);\n    }"
  ],
  "BGTStaker._safeTransferFromStakeToken": [
    "function _safeTransferFromStakeToken(address from, uint256 amount) internal override { }"
  ],
  "BGTStaker._safeTransferStakeToken": [
    "function _safeTransferStakeToken(address to, uint256 amount) internal override { }"
  ],
  "BeaconDeposit.supportsInterface": [
    "function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(ERC165).interfaceId || interfaceId == type(IBeaconDeposit).interfaceId;\n    }"
  ],
  "BeaconDeposit.getOperator": [
    "function getOperator(bytes calldata pubkey) external view returns (address) {\n        return _operatorByPubKey[pubkey];\n    }"
  ],
  "BeaconDeposit.deposit": [
    "function deposit(\n        bytes calldata pubkey,\n        bytes calldata credentials,\n        bytes calldata signature,\n        address operator\n    )\n        external\n        payable\n    {\n        if (pubkey.length != PUBLIC_KEY_LENGTH) {\n            InvalidPubKeyLength.selector.revertWith();\n        }\n        if (credentials.length != CREDENTIALS_LENGTH) {\n            InvalidCredentialsLength.selector.revertWith();\n        }\n        if (signature.length != SIGNATURE_LENGTH) {\n            InvalidSignatureLength.selector.revertWith();\n        }\n        if (_operatorByPubKey[pubkey] == address(0)) {\n            if (operator == address(0)) {\n                ZeroOperatorOnFirstDeposit.selector.revertWith();\n            }\n            _operatorByPubKey[pubkey] = operator;\n            emit OperatorUpdated(pubkey, operator, address(0));\n        }\n        else if (operator != address(0)) {\n            OperatorAlreadySet.selector.revertWith();\n        }\n        uint64 amountInGwei = _deposit();\n        if (amountInGwei < MIN_DEPOSIT_AMOUNT_IN_GWEI) {\n            InsufficientDeposit.selector.revertWith();\n        }\n        emit Deposit(pubkey, credentials, amountInGwei, signature, depositCount++);\n    }"
  ],
  "BeaconDeposit.requestOperatorChange": [
    "function requestOperatorChange(bytes calldata pubkey, address newOperator) external {\n        address currentOperator = _operatorByPubKey[pubkey];\n        if (msg.sender != currentOperator) {\n            NotOperator.selector.revertWith();\n        }\n        if (newOperator == address(0)) {\n            ZeroAddress.selector.revertWith();\n        }\n        QueuedOperator storage qO = queuedOperator[pubkey];\n        qO.newOperator = newOperator;\n        qO.queuedTimestamp = uint96(block.timestamp);\n        emit OperatorChangeQueued(pubkey, newOperator, currentOperator, block.timestamp);\n    }"
  ],
  "BeaconDeposit.cancelOperatorChange": [
    "function cancelOperatorChange(bytes calldata pubkey) external {\n        if (msg.sender != _operatorByPubKey[pubkey]) {\n            NotOperator.selector.revertWith();\n        }\n        delete queuedOperator[pubkey];\n        emit OperatorChangeCancelled(pubkey);\n    }"
  ],
  "BeaconDeposit.acceptOperatorChange": [
    "function acceptOperatorChange(bytes calldata pubkey) external {\n        QueuedOperator storage qO = queuedOperator[pubkey];\n        (address newOperator, uint96 queuedTimestamp) = (qO.newOperator, qO.queuedTimestamp);\n        if (msg.sender != newOperator) {\n            NotNewOperator.selector.revertWith();\n        }\n        if (queuedTimestamp + ONE_DAY > uint96(block.timestamp)) {\n            NotEnoughTime.selector.revertWith();\n        }\n        address oldOperator = _operatorByPubKey[pubkey];\n        _operatorByPubKey[pubkey] = newOperator;\n        delete queuedOperator[pubkey];\n        emit OperatorUpdated(pubkey, newOperator, oldOperator);\n    }"
  ],
  "BeaconDeposit._deposit": [
    "function _deposit() internal virtual returns (uint64) {\n        if (msg.value % 1 gwei != 0) {\n            DepositNotMultipleOfGwei.selector.revertWith();\n        }\n        uint256 amountInGwei = msg.value / 1 gwei;\n        if (amountInGwei > type(uint64).max) {\n            DepositValueTooHigh.selector.revertWith();\n        }\n        _safeTransferETH(address(0), msg.value);\n        return uint64(amountInGwei);\n    }"
  ],
  "BeaconDeposit._safeTransferETH": [
    "function _safeTransferETH(address to, uint256 amount) internal {\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) \n                revert(0x1c, 0x04)\n            }\n        }\n    }"
  ],
  "BGT.initialize": [
    "function initialize(address _owner) external initializer {\n        __Ownable_init(_owner);\n        __ERC20_init(NAME, SYMBOL);\n        activateBoostDelay = BOOST_MAX_BLOCK_DELAY;\n        dropBoostDelay = BOOST_MAX_BLOCK_DELAY;\n    }"
  ],
  "BGT.onlyBlockRewardController": [
    "modifier onlyBlockRewardController() {\n        if (msg.sender != _blockRewardController) NotBlockRewardController.selector.revertWith();\n        _;\n    }"
  ],
  "BGT.onlyApprovedSender": [
    "modifier onlyApprovedSender(address sender) {\n        if (!isWhitelistedSender[sender]) NotApprovedSender.selector.revertWith();\n        _;\n    }"
  ],
  "BGT.checkUnboostedBalance": [
    "modifier checkUnboostedBalance(address sender, uint256 amount) {\n        _checkUnboostedBalance(sender, amount);\n        _;\n    }"
  ],
  "BGT.invariantCheck": [
    "modifier invariantCheck() {\n        _;\n        _invariantCheck();\n    }"
  ],
  "BGT.whitelistSender": [
    "function whitelistSender(address sender, bool approved) external onlyOwner {\n        isWhitelistedSender[sender] = approved;\n        emit SenderWhitelisted(sender, approved);\n    }"
  ],
  "BGT.setMinter": [
    "function setMinter(address _minter) external onlyOwner {\n        if (_minter == address(0)) ZeroAddress.selector.revertWith();\n        emit MinterChanged(_blockRewardController, _minter);\n        _blockRewardController = _minter;\n    }"
  ],
  "BGT.mint": [
    "function mint(address distributor, uint256 amount) external onlyBlockRewardController invariantCheck {\n        super._mint(distributor, amount);\n    }"
  ],
  "BGT.setStaker": [
    "function setStaker(address _staker) external onlyOwner {\n        if (_staker == address(0)) ZeroAddress.selector.revertWith();\n        emit StakerChanged(staker, _staker);\n        staker = _staker;\n    }"
  ],
  "BGT.setActivateBoostDelay": [
    "function setActivateBoostDelay(uint32 _activateBoostDelay) external onlyOwner {\n        if (_activateBoostDelay == 0 || _activateBoostDelay > BOOST_MAX_BLOCK_DELAY) {\n            InvalidActivateBoostDelay.selector.revertWith();\n        }\n        activateBoostDelay = _activateBoostDelay;\n        emit ActivateBoostDelayChanged(_activateBoostDelay);\n    }"
  ],
  "BGT.setDropBoostDelay": [
    "function setDropBoostDelay(uint32 _dropBoostDelay) external onlyOwner {\n        if (_dropBoostDelay == 0 || _dropBoostDelay > BOOST_MAX_BLOCK_DELAY) {\n            InvalidDropBoostDelay.selector.revertWith();\n        }\n        dropBoostDelay = _dropBoostDelay;\n        emit DropBoostDelayChanged(_dropBoostDelay);\n    }"
  ],
  "BGT.setBgtTermsAndConditions": [
    "function setBgtTermsAndConditions(string calldata _bgtTermsAndConditions) external onlyOwner {\n        bgtTermsAndConditions = _bgtTermsAndConditions;\n        emit BgtTermsAndConditionsChanged(_bgtTermsAndConditions);\n    }"
  ],
  "BGT.queueBoost": [
    "function queueBoost(bytes calldata pubkey, uint128 amount) external checkUnboostedBalance(msg.sender, amount) {\n        userBoosts[msg.sender].queuedBoost += amount;\n        unchecked {\n            QueuedBoost storage qb = boostedQueue[msg.sender][pubkey];\n            uint128 balance = qb.balance + amount;\n            (qb.balance, qb.blockNumberLast) = (balance, uint32(block.number));\n        }\n        emit QueueBoost(msg.sender, pubkey, amount);\n    }"
  ],
  "BGT.cancelBoost": [
    "function cancelBoost(bytes calldata pubkey, uint128 amount) external {\n        QueuedBoost storage qb = boostedQueue[msg.sender][pubkey];\n        qb.balance -= amount;\n        unchecked {\n            userBoosts[msg.sender].queuedBoost -= amount;\n        }\n        emit CancelBoost(msg.sender, pubkey, amount);\n    }"
  ],
  "BGT.activateBoost": [
    "function activateBoost(address user, bytes calldata pubkey) external returns (bool) {\n        QueuedBoost storage qb = boostedQueue[user][pubkey];\n        (uint32 blockNumberLast, uint128 amount) = (qb.blockNumberLast, qb.balance);\n        if (amount == 0 || !_checkEnoughTimePassed(blockNumberLast, activateBoostDelay)) return false;\n        totalBoosts += amount;\n        unchecked {\n            boostees[pubkey] += amount;\n            boosted[user][pubkey] += amount;\n            UserBoost storage userBoost = userBoosts[user];\n            (uint128 boost, uint128 _queuedBoost) = (userBoost.boost, userBoost.queuedBoost);\n            (userBoost.boost, userBoost.queuedBoost) = (boost + amount, _queuedBoost - amount);\n        }\n        delete boostedQueue[user][pubkey];\n        IBGTStaker(staker).stake(user, amount);\n        emit ActivateBoost(msg.sender, user, pubkey, amount);\n        return true;\n    }"
  ],
  "BGT.queueDropBoost": [
    "function queueDropBoost(bytes calldata pubkey, uint128 amount) external {\n        QueuedDropBoost storage qdb = dropBoostQueue[msg.sender][pubkey];\n        uint128 dropBalance = qdb.balance + amount;\n        if (boosted[msg.sender][pubkey] < dropBalance) NotEnoughBoostedBalance.selector.revertWith();\n        (qdb.balance, qdb.blockNumberLast) = (dropBalance, uint32(block.number));\n        emit QueueDropBoost(msg.sender, pubkey, amount);\n    }"
  ],
  "BGT.cancelDropBoost": [
    "function cancelDropBoost(bytes calldata pubkey, uint128 amount) external {\n        QueuedDropBoost storage qdb = dropBoostQueue[msg.sender][pubkey];\n        qdb.balance -= amount;\n        emit CancelDropBoost(msg.sender, pubkey, amount);\n    }"
  ],
  "BGT.dropBoost": [
    "function dropBoost(address user, bytes calldata pubkey) external returns (bool) {\n        QueuedDropBoost storage qdb = dropBoostQueue[user][pubkey];\n        (uint32 blockNumberLast, uint128 amount) = (qdb.blockNumberLast, qdb.balance);\n        if (amount == 0 || !_checkEnoughTimePassed(blockNumberLast, dropBoostDelay)) return false;\n        unchecked {\n            boosted[user][pubkey] -= amount;\n            totalBoosts -= amount;\n            userBoosts[user].boost -= amount;\n            boostees[pubkey] -= amount;\n        }\n        delete dropBoostQueue[user][pubkey];\n        IBGTStaker(staker).withdraw(user, amount);\n        emit DropBoost(msg.sender, user, pubkey, amount);\n        return true;\n    }"
  ],
  "BGT.approve": [
    "function approve(\n        address spender,\n        uint256 amount\n    )\n        public\n        override(IERC20, ERC20Upgradeable)\n        onlyApprovedSender(msg.sender)\n        returns (bool)\n    {\n        return super.approve(spender, amount);\n    }"
  ],
  "BGT.transfer": [
    "function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        override(IERC20, ERC20Upgradeable)\n        onlyApprovedSender(msg.sender)\n        checkUnboostedBalance(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }"
  ],
  "BGT.transferFrom": [
    "function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        override(IERC20, ERC20Upgradeable)\n        onlyApprovedSender(from)\n        checkUnboostedBalance(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }"
  ],
  "BGT.redeem": [
    "function redeem(\n        address receiver,\n        uint256 amount\n    )\n        external\n        invariantCheck\n        checkUnboostedBalance(msg.sender, amount)\n    {\n        super._burn(msg.sender, amount);\n        SafeTransferLib.safeTransferETH(receiver, amount);\n        emit Redeem(msg.sender, receiver, amount);\n    }"
  ],
  "BGT.burnExceedingReserves": [
    "function burnExceedingReserves() external {\n        IBlockRewardController br = IBlockRewardController(_blockRewardController);\n        uint256 potentialMintableBGT = HISTORY_BUFFER_LENGTH * br.getMaxBGTPerBlock();\n        uint256 currentReservesAmount = address(this).balance;\n        uint256 outstandingRequiredAmount = totalSupply() + potentialMintableBGT;\n        if (currentReservesAmount <= outstandingRequiredAmount) return;\n        uint256 excessAmountToBurn = currentReservesAmount - outstandingRequiredAmount;\n        SafeTransferLib.safeTransferETH(address(0), excessAmountToBurn);\n        emit ExceedingReservesBurnt(msg.sender, excessAmountToBurn);\n    }"
  ],
  "BGT.minter": [
    "function minter() external view returns (address) {\n        return _blockRewardController;\n    }"
  ],
  "BGT.normalizedBoost": [
    "function normalizedBoost(bytes calldata pubkey) external view returns (uint256) {\n        if (totalBoosts == 0) return 0;\n        return FixedPointMathLib.divWad(boostees[pubkey], totalBoosts);\n    }"
  ],
  "BGT.boosts": [
    "function boosts(address account) external view returns (uint128) {\n        return userBoosts[account].boost;\n    }"
  ],
  "BGT.queuedBoost": [
    "function queuedBoost(address account) external view returns (uint128) {\n        return userBoosts[account].queuedBoost;\n    }"
  ],
  "BGT.name": [
    "function name() public pure override(IERC20Metadata, ERC20Upgradeable) returns (string memory) {\n        return NAME;\n    }"
  ],
  "BGT.symbol": [
    "function symbol() public pure override(IERC20Metadata, ERC20Upgradeable) returns (string memory) {\n        return SYMBOL;\n    }"
  ],
  "BGT.unboostedBalanceOf": [
    "function unboostedBalanceOf(address account) public view returns (uint256) {\n        UserBoost storage userBoost = userBoosts[account];\n        (uint128 boost, uint128 _queuedBoost) = (userBoost.boost, userBoost.queuedBoost);\n        return balanceOf(account) - boost - _queuedBoost;\n    }"
  ],
  "BGT.clock": [
    "function clock() public view virtual override returns (uint48) {\n        return Time.timestamp();\n    }"
  ],
  "BGT.CLOCK_MODE": [
    "function CLOCK_MODE() public view virtual override returns (string memory) {\n        return \"mode=timestamp\";\n    }"
  ],
  "BGT._checkUnboostedBalance": [
    "function _checkUnboostedBalance(address sender, uint256 amount) private view {\n        if (unboostedBalanceOf(sender) < amount) NotEnoughBalance.selector.revertWith();\n    }"
  ],
  "BGT._checkEnoughTimePassed": [
    "function _checkEnoughTimePassed(uint32 blockNumberLast, uint32 blockBufferDelay) private view returns (bool) {\n        unchecked {\n            uint32 delta = uint32(block.number) - blockNumberLast;\n            if (delta <= blockBufferDelay) return false;\n        }\n        return true;\n    }"
  ],
  "BGT._invariantCheck": [
    "function _invariantCheck() private view {\n        if (address(this).balance < totalSupply()) InvariantCheckFailed.selector.revertWith();\n    }"
  ],
  "RewardVault.initialize": [
    "function initialize(\n        address _beaconDepositContract,\n        address _bgt,\n        address _distributor,\n        address _stakingToken\n    )\n        external\n        initializer\n    {\n        __FactoryOwnable_init(msg.sender);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __StakingRewards_init(_stakingToken, _bgt, 3 days);\n        maxIncentiveTokensCount = 3;\n        distributor = _distributor;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        emit DistributorSet(_distributor);\n        emit MaxIncentiveTokensCountUpdated(maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) NotDistributor.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault.onlyOperatorOrUser": [
    "modifier onlyOperatorOrUser(address account) {\n        if (msg.sender != account) {\n            if (msg.sender != _operators[account]) NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "RewardVault.checkSelfStakedBalance": [
    "modifier checkSelfStakedBalance(address account, uint256 amount) {\n        _checkSelfStakedBalance(account, amount);\n        _;\n    }"
  ],
  "RewardVault.onlyWhitelistedToken": [
    "modifier onlyWhitelistedToken(address token) {\n        if (incentives[token].minIncentiveRate == 0) TokenNotWhitelisted.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault.setDistributor": [
    "function setDistributor(address _rewardDistribution) external onlyFactoryOwner {\n        if (_rewardDistribution == address(0)) ZeroAddress.selector.revertWith();\n        distributor = _rewardDistribution;\n        emit DistributorSet(_rewardDistribution);\n    }"
  ],
  "RewardVault.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external onlyDistributor {\n        _notifyRewardAmount(reward);\n        _processIncentives(pubkey, reward);\n    }"
  ],
  "RewardVault.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyFactoryOwner {\n        if (incentives[tokenAddress].minIncentiveRate != 0) CannotRecoverIncentiveToken.selector.revertWith();\n        if (tokenAddress == address(stakeToken)) {\n            uint256 maxRecoveryAmount = IERC20(stakeToken).balanceOf(address(this)) - totalSupply;\n            if (tokenAmount > maxRecoveryAmount) {\n                NotEnoughBalance.selector.revertWith();\n            }\n        }\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }"
  ],
  "RewardVault.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external onlyFactoryOwner {\n        _setRewardsDuration(_rewardsDuration);\n    }"
  ],
  "RewardVault.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(\n        address token,\n        uint256 minIncentiveRate,\n        address manager\n    )\n        external\n        onlyFactoryOwner\n    {\n        if (minIncentiveRate == 0) MinIncentiveRateIsZero.selector.revertWith();\n        if (minIncentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        if (token == address(0) || manager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        if (whitelistedTokens.length == maxIncentiveTokensCount || incentive.minIncentiveRate != 0) {\n            TokenAlreadyWhitelistedOrLimitReached.selector.revertWith();\n        }\n        whitelistedTokens.push(token);\n        incentive.incentiveRate = minIncentiveRate;\n        incentive.minIncentiveRate = minIncentiveRate;\n        incentive.manager = manager;\n        emit IncentiveTokenWhitelisted(token, minIncentiveRate, manager);\n    }"
  ],
  "RewardVault.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external onlyFactoryVaultManager onlyWhitelistedToken(token) {\n        delete incentives[token];\n        _deleteWhitelistedTokenFromList(token);\n        emit IncentiveTokenRemoved(token);\n    }"
  ],
  "RewardVault.updateIncentiveManager": [
    "function updateIncentiveManager(\n        address token,\n        address newManager\n    )\n        external\n        onlyFactoryOwner\n        onlyWhitelistedToken(token)\n    {\n        if (newManager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        address currentManager = incentive.manager;\n        incentive.manager = newManager;\n        emit IncentiveManagerChanged(token, newManager, currentManager);\n    }"
  ],
  "RewardVault.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external onlyFactoryOwner {\n        if (_maxIncentiveTokensCount < whitelistedTokens.length) {\n            InvalidMaxIncentiveTokensCount.selector.revertWith();\n        }\n        maxIncentiveTokensCount = _maxIncentiveTokensCount;\n        emit MaxIncentiveTokensCountUpdated(_maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault.pause": [
    "function pause() external onlyFactoryVaultPauser {\n        _pause();\n    }"
  ],
  "RewardVault.unpause": [
    "function unpause() external onlyFactoryVaultManager {\n        _unpause();\n    }"
  ],
  "RewardVault.operator": [
    "function operator(address account) external view returns (address) {\n        return _operators[account];\n    }"
  ],
  "RewardVault.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256) {\n        return whitelistedTokens.length;\n    }"
  ],
  "RewardVault.getWhitelistedTokens": [
    "function getWhitelistedTokens() public view returns (address[] memory) {\n        return whitelistedTokens;\n    }"
  ],
  "RewardVault.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256) {\n        return _delegateStake[account].delegateTotalStaked;\n    }"
  ],
  "RewardVault.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256) {\n        return _delegateStake[account].stakedByDelegate[delegate];\n    }"
  ],
  "RewardVault.stake": [
    "function stake(uint256 amount) external nonReentrant whenNotPaused {\n        _stake(msg.sender, amount);\n    }"
  ],
  "RewardVault.delegateStake": [
    "function delegateStake(address account, uint256 amount) external nonReentrant whenNotPaused {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        _stake(account, amount);\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            info.delegateTotalStaked += amount;\n            info.stakedByDelegate[msg.sender] += amount;\n        }\n        emit DelegateStaked(account, msg.sender, amount);\n    }"
  ],
  "RewardVault.withdraw": [
    "function withdraw(uint256 amount) external nonReentrant checkSelfStakedBalance(msg.sender, amount) {\n        _withdraw(msg.sender, amount);\n    }"
  ],
  "RewardVault.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external nonReentrant {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            uint256 stakedByDelegate = info.stakedByDelegate[msg.sender];\n            if (stakedByDelegate < amount) InsufficientDelegateStake.selector.revertWith();\n            info.stakedByDelegate[msg.sender] = stakedByDelegate - amount;\n            info.delegateTotalStaked -= amount;\n        }\n        _withdraw(account, amount);\n        emit DelegateWithdrawn(account, msg.sender, amount);\n    }"
  ],
  "RewardVault.getReward": [
    "function getReward(\n        address account,\n        address recipient\n    )\n        external\n        nonReentrant\n        onlyOperatorOrUser(account)\n        returns (uint256)\n    {\n        return _getReward(account, recipient);\n    }"
  ],
  "RewardVault.exit": [
    "function exit(address recipient) external nonReentrant {\n        uint256 amount = _accountInfo[msg.sender].balance - _delegateStake[msg.sender].delegateTotalStaked;\n        _withdraw(msg.sender, amount);\n        _getReward(msg.sender, recipient);\n    }"
  ],
  "RewardVault.setOperator": [
    "function setOperator(address _operator) external {\n        _operators[msg.sender] = _operator;\n        emit OperatorSet(msg.sender, _operator);\n    }"
  ],
  "RewardVault.addIncentive": [
    "function addIncentive(\n        address token,\n        uint256 amount,\n        uint256 incentiveRate\n    )\n        external\n        nonReentrant\n        onlyWhitelistedToken(token)\n    {\n        if (incentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        if (incentiveRate < minIncentiveRate) InvalidIncentiveRate.selector.revertWith();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        incentive.amountRemaining = amountRemainingBefore + amount;\n        if (amountRemainingBefore == 0) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else if (incentiveRate >= incentiveRateStored) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else {\n            InvalidIncentiveRate.selector.revertWith();\n        }\n        emit IncentiveAdded(token, msg.sender, amount, incentive.incentiveRate);\n    }"
  ],
  "RewardVault.accountIncentives": [
    "function accountIncentives(address token, uint256 amount) external nonReentrant onlyWhitelistedToken(token) {\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        uint256 incentiveBalance = IERC20(token).balanceOf(address(this));\n        if (token == address(stakeToken)) {\n            incentiveBalance -= totalSupply;\n        }\n        if (amount > incentiveBalance - amountRemainingBefore) NotEnoughBalance.selector.revertWith();\n        incentive.amountRemaining += amount;\n        emit IncentiveAdded(token, msg.sender, amount, incentiveRateStored);\n    }"
  ],
  "RewardVault._checkSelfStakedBalance": [
    "function _checkSelfStakedBalance(address account, uint256 amount) internal view {\n        unchecked {\n            uint256 selfStaked = _accountInfo[account].balance - _delegateStake[account].delegateTotalStaked;\n            if (selfStaked < amount) InsufficientSelfStake.selector.revertWith();\n        }\n    }"
  ],
  "RewardVault._safeTransferRewardToken": [
    "function _safeTransferRewardToken(address to, uint256 amount) internal override {\n        rewardToken.safeTransferFrom(distributor, to, amount);\n    }"
  ],
  "RewardVault._checkRewardSolvency": [
    "function _checkRewardSolvency() internal view override {\n        uint256 allowance = rewardToken.allowance(distributor, address(this));\n        if (undistributedRewards / PRECISION > allowance) InsolventReward.selector.revertWith();\n    }"
  ],
  "RewardVault._processIncentives": [
    "function _processIncentives(bytes calldata pubkey, uint256 bgtEmitted) internal {\n        address _operator = beaconDepositContract.getOperator(pubkey);\n        IBeraChef beraChef = IDistributor(distributor).beraChef();\n        address bgtIncentiveDistributor = getBGTIncentiveDistributor();\n        uint256 whitelistedTokensCount = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < whitelistedTokensCount; ++i) {\n                address token = whitelistedTokens[i];\n                Incentive storage incentive = incentives[token];\n                uint256 amount = FixedPointMathLib.mulDiv(bgtEmitted, incentive.incentiveRate, PRECISION);\n                uint256 amountRemaining = incentive.amountRemaining;\n                amount = FixedPointMathLib.min(amount, amountRemaining);\n                uint256 validatorShare;\n                if (amount > 0) {\n                    validatorShare = beraChef.getValidatorIncentiveTokenShare(pubkey, amount);\n                    amount -= validatorShare;\n                }\n                if (validatorShare > 0) {\n                    bool success = token.trySafeTransfer(_operator, validatorShare);\n                    if (success) {\n                        amountRemaining -= validatorShare;\n                        emit IncentivesProcessed(pubkey, token, bgtEmitted, validatorShare);\n                    } else {\n                        emit IncentivesProcessFailed(pubkey, token, bgtEmitted, validatorShare);\n                    }\n                }\n                if (amount > 0) {\n                    bytes memory data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, amount));\n                    (bool success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                    if (success) {\n                        data = abi.encodeCall(IBGTIncentiveDistributor.receiveIncentive, (pubkey, token, amount));\n                        (success,) = bgtIncentiveDistributor.call{ gas: SAFE_GAS_LIMIT }(data);\n                        if (success) {\n                            amountRemaining -= amount;\n                            emit BGTBoosterIncentivesProcessed(pubkey, token, bgtEmitted, amount);\n                        } else {\n                            data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, 0));\n                            (success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                            emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                        }\n                    }\n                    else {\n                        emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                    }\n                }\n                incentive.amountRemaining = amountRemaining;\n            }\n        }\n    }"
  ],
  "RewardVault._deleteWhitelistedTokenFromList": [
    "function _deleteWhitelistedTokenFromList(address token) internal {\n        uint256 activeTokens = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < activeTokens; ++i) {\n                if (token == whitelistedTokens[i]) {\n                    whitelistedTokens[i] = whitelistedTokens[activeTokens - 1];\n                    whitelistedTokens.pop();\n                    return;\n                }\n            }\n        }\n    }"
  ],
  "BlockRewardController.initialize": [
    "function initialize(\n        address _bgt,\n        address _distributor,\n        address _beaconDepositContract,\n        address _governance\n    )\n        external\n        initializer\n    {\n        __Ownable_init(_governance);\n        __UUPSUpgradeable_init();\n        bgt = BGT(_bgt);\n        emit SetDistributor(_distributor);\n        distributor = _distributor;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n    }"
  ],
  "BlockRewardController._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }"
  ],
  "BlockRewardController.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) {\n            NotDistributor.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "BlockRewardController.setBaseRate": [
    "function setBaseRate(uint256 _baseRate) external onlyOwner {\n        if (_baseRate > MAX_BASE_RATE) {\n            InvalidBaseRate.selector.revertWith();\n        }\n        emit BaseRateChanged(baseRate, _baseRate);\n        baseRate = _baseRate;\n    }"
  ],
  "BlockRewardController.setRewardRate": [
    "function setRewardRate(uint256 _rewardRate) external onlyOwner {\n        if (_rewardRate > MAX_REWARD_RATE) {\n            InvalidRewardRate.selector.revertWith();\n        }\n        emit RewardRateChanged(rewardRate, _rewardRate);\n        rewardRate = _rewardRate;\n    }"
  ],
  "BlockRewardController.setMinBoostedRewardRate": [
    "function setMinBoostedRewardRate(uint256 _minBoostedRewardRate) external onlyOwner {\n        if (_minBoostedRewardRate > MAX_MIN_BOOSTED_REWARD_RATE) {\n            InvalidMinBoostedRewardRate.selector.revertWith();\n        }\n        emit MinBoostedRewardRateChanged(minBoostedRewardRate, _minBoostedRewardRate);\n        minBoostedRewardRate = _minBoostedRewardRate;\n    }"
  ],
  "BlockRewardController.setBoostMultiplier": [
    "function setBoostMultiplier(uint256 _boostMultiplier) external onlyOwner {\n        if (_boostMultiplier > MAX_BOOST_MULTIPLIER) {\n            InvalidBoostMultiplier.selector.revertWith();\n        }\n        emit BoostMultiplierChanged(boostMultiplier, _boostMultiplier);\n        boostMultiplier = _boostMultiplier;\n    }"
  ],
  "BlockRewardController.setRewardConvexity": [
    "function setRewardConvexity(uint256 _rewardConvexity) external onlyOwner {\n        if (_rewardConvexity == 0 || _rewardConvexity > MAX_REWARD_CONVEXITY) {\n            InvalidRewardConvexity.selector.revertWith();\n        }\n        emit RewardConvexityChanged(uint256(rewardConvexity), _rewardConvexity);\n        rewardConvexity = int256(_rewardConvexity);\n    }"
  ],
  "BlockRewardController.setDistributor": [
    "function setDistributor(address _distributor) external onlyOwner {\n        if (_distributor == address(0)) {\n            ZeroAddress.selector.revertWith();\n        }\n        emit SetDistributor(_distributor);\n        distributor = _distributor;\n    }"
  ],
  "BlockRewardController.computeReward": [
    "function computeReward(\n        uint256 boostPower,\n        uint256 _rewardRate,\n        uint256 _boostMultiplier,\n        int256 _rewardConvexity\n    )\n        public\n        pure\n        returns (uint256 reward)\n    {\n        if (boostPower > 0) {\n            uint256 one = FixedPointMathLib.WAD;\n            if (boostPower == one) {\n                reward = FixedPointMathLib.mulWad(_rewardRate, _boostMultiplier);\n            } else {\n                uint256 tmp_0 = uint256(FixedPointMathLib.powWad(int256(boostPower), _rewardConvexity));\n                uint256 tmp_1 = one + FixedPointMathLib.mulWad(_boostMultiplier, tmp_0);\n                uint256 tmp_2 = one - FixedPointMathLib.divWad(one, tmp_1);\n                uint256 coeff = FixedPointMathLib.mulWad(tmp_2, one + _boostMultiplier);\n                if (coeff > _boostMultiplier) coeff = _boostMultiplier;\n                reward = FixedPointMathLib.mulWad(_rewardRate, coeff);\n            }\n        }\n    }"
  ],
  "BlockRewardController.getMaxBGTPerBlock": [
    "function getMaxBGTPerBlock() public view returns (uint256 amount) {\n        amount = computeReward(FixedPointMathLib.WAD, rewardRate, boostMultiplier, rewardConvexity);\n        if (amount < minBoostedRewardRate) {\n            amount = minBoostedRewardRate;\n        }\n        amount += baseRate;\n    }"
  ],
  "BlockRewardController.processRewards": [
    "function processRewards(\n        bytes calldata pubkey,\n        uint64 nextTimestamp,\n        bool isReady\n    )\n        external\n        onlyDistributor\n        returns (uint256)\n    {\n        uint256 base = baseRate;\n        uint256 reward = 0;\n        if (isReady) {\n            uint256 boostPower = bgt.normalizedBoost(pubkey);\n            reward = computeReward(boostPower, rewardRate, boostMultiplier, rewardConvexity);\n            if (reward < minBoostedRewardRate) reward = minBoostedRewardRate;\n        }\n        emit BlockRewardProcessed(pubkey, nextTimestamp, base, reward);\n        address operator = beaconDepositContract.getOperator(pubkey);\n        if (base > 0) bgt.mint(operator, base);\n        if (reward > 0) bgt.mint(distributor, reward);\n        return reward;\n    }"
  ],
  "BeraChef.initialize": [
    "function initialize(\n        address _distributor,\n        address _factory,\n        address _governance,\n        address _beaconDepositContract,\n        uint8 _maxNumWeightsPerRewardAllocation\n    )\n        external\n        initializer\n    {\n        __Ownable_init(_governance);\n        __UUPSUpgradeable_init();\n        distributor = _distributor;\n        factory = _factory;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        if (_maxNumWeightsPerRewardAllocation == 0) {\n            MaxNumWeightsPerRewardAllocationIsZero.selector.revertWith();\n        }\n        emit MaxNumWeightsPerRewardAllocationSet(_maxNumWeightsPerRewardAllocation);\n        maxNumWeightsPerRewardAllocation = _maxNumWeightsPerRewardAllocation;\n    }"
  ],
  "BeraChef._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }"
  ],
  "BeraChef.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) {\n            NotDistributor.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "BeraChef.onlyOperator": [
    "modifier onlyOperator(bytes calldata valPubkey) {\n        if (msg.sender != beaconDepositContract.getOperator(valPubkey)) {\n            NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "BeraChef.setMaxNumWeightsPerRewardAllocation": [
    "function setMaxNumWeightsPerRewardAllocation(uint8 _maxNumWeightsPerRewardAllocation) external onlyOwner {\n        if (_maxNumWeightsPerRewardAllocation == 0) {\n            MaxNumWeightsPerRewardAllocationIsZero.selector.revertWith();\n        }\n        if (_maxNumWeightsPerRewardAllocation < defaultRewardAllocation.weights.length) {\n            InvalidateDefaultRewardAllocation.selector.revertWith();\n        }\n        maxNumWeightsPerRewardAllocation = _maxNumWeightsPerRewardAllocation;\n        emit MaxNumWeightsPerRewardAllocationSet(_maxNumWeightsPerRewardAllocation);\n    }"
  ],
  "BeraChef.setMaxWeightPerVault": [
    "function setMaxWeightPerVault(uint96 _maxWeightPerVault) external onlyOwner {\n        if (_maxWeightPerVault == 0 || _maxWeightPerVault > ONE_HUNDRED_PERCENT) {\n            InvalidMaxWeightPerVault.selector.revertWith();\n        }\n        maxWeightPerVault = _maxWeightPerVault;\n        if (!_checkIfStillValid(defaultRewardAllocation.weights)) {\n            InvalidateDefaultRewardAllocation.selector.revertWith();\n        }\n        emit MaxWeightPerVaultSet(_maxWeightPerVault);\n    }"
  ],
  "BeraChef.setRewardAllocationBlockDelay": [
    "function setRewardAllocationBlockDelay(uint64 _rewardAllocationBlockDelay) external onlyOwner {\n        if (_rewardAllocationBlockDelay > MAX_REWARD_ALLOCATION_BLOCK_DELAY) {\n            RewardAllocationBlockDelayTooLarge.selector.revertWith();\n        }\n        rewardAllocationBlockDelay = _rewardAllocationBlockDelay;\n        emit RewardAllocationBlockDelaySet(_rewardAllocationBlockDelay);\n    }"
  ],
  "BeraChef.setVaultWhitelistedStatus": [
    "function setVaultWhitelistedStatus(\n        address receiver,\n        bool isWhitelisted,\n        string memory metadata\n    )\n        external\n        onlyOwner\n    {\n        address stakeToken = address(RewardVault(receiver).stakeToken());\n        address factoryVault = IRewardVaultFactory(factory).getVault(stakeToken);\n        if (receiver != factoryVault) {\n            NotFactoryVault.selector.revertWith();\n        }\n        isWhitelistedVault[receiver] = isWhitelisted;\n        if (!isWhitelisted) {\n            if (!_checkIfStillValid(defaultRewardAllocation.weights)) {\n                InvalidateDefaultRewardAllocation.selector.revertWith();\n            }\n        }\n        emit VaultWhitelistedStatusUpdated(receiver, isWhitelisted, metadata);\n    }"
  ],
  "BeraChef.updateWhitelistedVaultMetadata": [
    "function updateWhitelistedVaultMetadata(address vault, string memory metadata) external onlyOwner {\n        if (!isWhitelistedVault[vault]) {\n            NotWhitelistedVault.selector.revertWith();\n        }\n        emit WhitelistedVaultMetadataUpdated(vault, metadata);\n    }"
  ],
  "BeraChef.setDefaultRewardAllocation": [
    "function setDefaultRewardAllocation(RewardAllocation calldata ra) external onlyOwner {\n        _validateWeights(ra.weights);\n        emit SetDefaultRewardAllocation(ra);\n        defaultRewardAllocation = ra;\n    }"
  ],
  "BeraChef.setCommissionChangeDelay": [
    "function setCommissionChangeDelay(uint64 _commissionChangeDelay) external onlyOwner {\n        if (_commissionChangeDelay == 0 || _commissionChangeDelay > MAX_COMMISSION_CHANGE_DELAY) {\n            InvalidCommissionChangeDelay.selector.revertWith();\n        }\n        commissionChangeDelay = _commissionChangeDelay;\n        emit CommissionChangeDelaySet(_commissionChangeDelay);\n    }"
  ],
  "BeraChef.queueNewRewardAllocation": [
    "function queueNewRewardAllocation(\n        bytes calldata valPubkey,\n        uint64 startBlock,\n        Weight[] calldata weights\n    )\n        external\n        onlyOperator(valPubkey)\n    {\n        if (startBlock <= block.number + rewardAllocationBlockDelay) {\n            InvalidStartBlock.selector.revertWith();\n        }\n        RewardAllocation storage qra = queuedRewardAllocations[valPubkey];\n        if (qra.startBlock > 0) {\n            RewardAllocationAlreadyQueued.selector.revertWith();\n        }\n        _validateWeights(weights);\n        qra.startBlock = startBlock;\n        Weight[] storage storageWeights = qra.weights;\n        for (uint256 i; i < weights.length;) {\n            storageWeights.push(weights[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        emit QueueRewardAllocation(valPubkey, startBlock, weights);\n    }"
  ],
  "BeraChef.queueValCommission": [
    "function queueValCommission(bytes calldata valPubkey, uint96 commissionRate) external onlyOperator(valPubkey) {\n        if (commissionRate > ONE_HUNDRED_PERCENT) {\n            InvalidCommissionValue.selector.revertWith();\n        }\n        QueuedCommissionRateChange storage qcr = valQueuedCommission[valPubkey];\n        if (qcr.blockNumberLast > 0) {\n            CommissionChangeAlreadyQueued.selector.revertWith();\n        }\n        (qcr.blockNumberLast, qcr.commissionRate) = (uint32(block.number), commissionRate);\n        emit QueuedValCommission(valPubkey, commissionRate);\n    }"
  ],
  "BeraChef.activateQueuedValCommission": [
    "function activateQueuedValCommission(bytes calldata valPubkey) external {\n        QueuedCommissionRateChange storage qcr = valQueuedCommission[valPubkey];\n        (uint32 blockNumberLast, uint96 commissionRate) = (qcr.blockNumberLast, qcr.commissionRate);\n        uint32 activationBlock = uint32(blockNumberLast + commissionChangeDelay);\n        if (blockNumberLast == 0 || block.number < activationBlock) {\n            CommissionNotQueuedOrDelayNotPassed.selector.revertWith();\n        }\n        uint96 oldCommission = _getOperatorCommission(valPubkey);\n        valCommission[valPubkey] = CommissionRate({ activationBlock: activationBlock, commissionRate: commissionRate });\n        emit ValCommissionSet(valPubkey, oldCommission, commissionRate);\n        delete valQueuedCommission[valPubkey];\n    }"
  ],
  "BeraChef.activateReadyQueuedRewardAllocation": [
    "function activateReadyQueuedRewardAllocation(bytes calldata valPubkey) external onlyDistributor {\n        if (!isQueuedRewardAllocationReady(valPubkey, block.number)) return;\n        RewardAllocation storage qra = queuedRewardAllocations[valPubkey];\n        uint64 startBlock = qra.startBlock;\n        activeRewardAllocations[valPubkey] = qra;\n        emit ActivateRewardAllocation(valPubkey, startBlock, qra.weights);\n        delete queuedRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef.getActiveRewardAllocation": [
    "function getActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        RewardAllocation memory ara = activeRewardAllocations[valPubkey];\n        if (ara.startBlock > 0 && _checkIfStillValid(ara.weights)) {\n            return ara;\n        }\n        return defaultRewardAllocation;\n    }"
  ],
  "BeraChef.getQueuedRewardAllocation": [
    "function getQueuedRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        return queuedRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef.getSetActiveRewardAllocation": [
    "function getSetActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        return activeRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef.getDefaultRewardAllocation": [
    "function getDefaultRewardAllocation() external view returns (RewardAllocation memory) {\n        return defaultRewardAllocation;\n    }"
  ],
  "BeraChef.isQueuedRewardAllocationReady": [
    "function isQueuedRewardAllocationReady(bytes calldata valPubkey, uint256 blockNumber) public view returns (bool) {\n        uint64 startBlock = queuedRewardAllocations[valPubkey].startBlock;\n        return startBlock != 0 && startBlock <= blockNumber;\n    }"
  ],
  "BeraChef.isReady": [
    "function isReady() external view returns (bool) {\n        return defaultRewardAllocation.weights.length > 0;\n    }"
  ],
  "BeraChef.getValCommissionOnIncentiveTokens": [
    "function getValCommissionOnIncentiveTokens(bytes calldata valPubkey) external view returns (uint96) {\n        return _getOperatorCommission(valPubkey);\n    }"
  ],
  "BeraChef.getValQueuedCommissionOnIncentiveTokens": [
    "function getValQueuedCommissionOnIncentiveTokens(bytes calldata valPubkey)\n        external\n        view\n        returns (QueuedCommissionRateChange memory)\n    {\n        return valQueuedCommission[valPubkey];\n    }"
  ],
  "BeraChef.getValidatorIncentiveTokenShare": [
    "function getValidatorIncentiveTokenShare(\n        bytes calldata valPubkey,\n        uint256 incentiveTokenAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint96 operatorCommission = _getOperatorCommission(valPubkey);\n        uint256 operatorShare = (incentiveTokenAmount * operatorCommission) / ONE_HUNDRED_PERCENT;\n        return operatorShare;\n    }"
  ],
  "BeraChef._validateWeights": [
    "function _validateWeights(Weight[] calldata weights) internal view {\n        if (weights.length > maxNumWeightsPerRewardAllocation) {\n            TooManyWeights.selector.revertWith();\n        }\n        uint96 totalWeight;\n        for (uint256 i; i < weights.length;) {\n            Weight calldata weight = weights[i];\n            if (weight.percentageNumerator == 0 || weight.percentageNumerator > maxWeightPerVault) {\n                InvalidWeight.selector.revertWith();\n            }\n            if (!isWhitelistedVault[weight.receiver]) {\n                NotWhitelistedVault.selector.revertWith();\n            }\n            totalWeight += weight.percentageNumerator;\n            unchecked {\n                ++i;\n            }\n        }\n        if (totalWeight != ONE_HUNDRED_PERCENT) {\n            InvalidRewardAllocationWeights.selector.revertWith();\n        }\n    }"
  ],
  "BeraChef._checkIfStillValid": [
    "function _checkIfStillValid(Weight[] memory weights) internal view returns (bool) {\n        uint256 length = weights.length;\n        if (length > maxNumWeightsPerRewardAllocation) {\n            return false;\n        }\n        for (uint256 i; i < length;) {\n            if (weights[i].percentageNumerator > maxWeightPerVault) {\n                return false;\n            }\n            if (!isWhitelistedVault[weights[i].receiver]) {\n                return false;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }"
  ],
  "BeraChef._getOperatorCommission": [
    "function _getOperatorCommission(bytes calldata valPubkey) internal view returns (uint96) {\n        CommissionRate memory operatorCommission = valCommission[valPubkey];\n        if (operatorCommission.activationBlock == 0) return DEFAULT_COMMISSION_RATE;\n        return operatorCommission.commissionRate;\n    }"
  ],
  "BGTIncentiveDistributor.initialize": [
    "function initialize(address _governance) external initializer {\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n        if (_governance == address(0)) ZeroAddress.selector.revertWith();\n        _grantRole(DEFAULT_ADMIN_ROLE, _governance);\n        _setRewardClaimDelay(MAX_REWARD_CLAIM_DELAY);\n    }"
  ],
  "BGTIncentiveDistributor._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "BGTIncentiveDistributor.setRewardClaimDelay": [
    "function setRewardClaimDelay(uint64 _delay) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setRewardClaimDelay(_delay);\n    }"
  ],
  "BGTIncentiveDistributor.updateRewardsMetadata": [
    "function updateRewardsMetadata(Distribution[] calldata _distributions) external onlyRole(MANAGER_ROLE) {\n        uint256 dLen = _distributions.length;\n        if (dLen == 0) InvalidDistribution.selector.revertWith();\n        uint256 activeAt = block.timestamp + rewardClaimDelay;\n        for (uint256 i; i < dLen;) {\n            Distribution calldata distribution = _distributions[i];\n            Reward storage reward = rewards[distribution.identifier];\n            reward.merkleRoot = distribution.merkleRoot;\n            reward.proof = distribution.proof;\n            reward.activeAt = activeAt;\n            reward.pubkey = distribution.pubkey;\n            if (reward.token == address(0)) {\n                reward.token = distribution.token;\n            } else if (reward.token != distribution.token) {\n                InvalidToken.selector.revertWith();\n            }\n            emit RewardMetadataUpdated(\n                distribution.identifier,\n                distribution.pubkey,\n                distribution.token,\n                distribution.merkleRoot,\n                distribution.proof,\n                activeAt\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }"
  ],
  "BGTIncentiveDistributor.setPauseState": [
    "function setPauseState(bool state) external onlyRole(PAUSER_ROLE) {\n        if (state) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }"
  ],
  "BGTIncentiveDistributor.receiveIncentive": [
    "function receiveIncentive(bytes calldata pubkey, address token, uint256 _amount) external {\n        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        incentiveTokensPerValidator[pubkey][token] += _amount;\n        emit IncentiveReceived(pubkey, token, _amount);\n    }"
  ],
  "BGTIncentiveDistributor.claim": [
    "function claim(Claim[] calldata _claims) external nonReentrant whenNotPaused {\n        uint256 cLen = _claims.length;\n        if (cLen == 0) InvalidArray.selector.revertWith();\n        for (uint256 i; i < cLen;) {\n            _claim(_claims[i].identifier, _claims[i].account, _claims[i].amount, _claims[i].merkleProof);\n            unchecked {\n                ++i;\n            }\n        }\n    }"
  ],
  "BGTIncentiveDistributor._claim": [
    "function _claim(bytes32 _identifier, address _account, uint256 _amount, bytes32[] calldata _merkleProof) private {\n        Reward memory reward = rewards[_identifier];\n        if (reward.merkleRoot == 0) InvalidMerkleRoot.selector.revertWith();\n        if (reward.activeAt > block.timestamp) RewardInactive.selector.revertWith();\n        uint256 lifeTimeAmount = claimed[_identifier][_account] + _amount;\n        if (\n            !MerkleProof.verifyCalldata(\n                _merkleProof, reward.merkleRoot, keccak256(abi.encodePacked(_account, lifeTimeAmount))\n            )\n        ) InvalidProof.selector.revertWith();\n        claimed[_identifier][_account] = lifeTimeAmount;\n        address token = reward.token;\n        bytes memory pubkey = reward.pubkey;\n        if (incentiveTokensPerValidator[pubkey][token] < _amount) {\n            InsufficientIncentiveTokens.selector.revertWith();\n        }\n        unchecked {\n            incentiveTokensPerValidator[pubkey][token] -= _amount;\n        }\n        IERC20(token).safeTransfer(_account, _amount);\n        emit RewardClaimed(_identifier, token, _account, pubkey, _amount);\n    }"
  ],
  "BGTIncentiveDistributor._setRewardClaimDelay": [
    "function _setRewardClaimDelay(uint64 _delay) internal {\n        if (_delay > MAX_REWARD_CLAIM_DELAY) {\n            InvalidRewardClaimDelay.selector.revertWith();\n        }\n        rewardClaimDelay = _delay;\n        emit RewardClaimDelaySet(_delay);\n    }"
  ],
  "Distributor.initialize": [
    "function initialize(\n        address _berachef,\n        address _bgt,\n        address _blockRewardController,\n        address _governance,\n        uint64 _zeroValidatorPubkeyGIndex,\n        uint64 _proposerIndexGIndex\n    )\n        external\n        initializer\n    {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, _governance);\n        beraChef = IBeraChef(_berachef);\n        bgt = _bgt;\n        blockRewardController = IBlockRewardController(_blockRewardController);\n        super.setZeroValidatorPubkeyGIndex(_zeroValidatorPubkeyGIndex);\n        super.setProposerIndexGIndex(_proposerIndexGIndex);\n    }"
  ],
  "Distributor._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "Distributor.setZeroValidatorPubkeyGIndex": [
    "function setZeroValidatorPubkeyGIndex(uint64 _zeroValidatorPubkeyGIndex) public override onlyRole(MANAGER_ROLE) {\n        super.setZeroValidatorPubkeyGIndex(_zeroValidatorPubkeyGIndex);\n    }"
  ],
  "Distributor.setProposerIndexGIndex": [
    "function setProposerIndexGIndex(uint64 _proposerIndexGIndex) public override onlyRole(MANAGER_ROLE) {\n        super.setProposerIndexGIndex(_proposerIndexGIndex);\n    }"
  ],
  "Distributor.distributeFor": [
    "function distributeFor(\n        uint64 nextTimestamp,\n        uint64 proposerIndex,\n        bytes calldata pubkey,\n        bytes32[] calldata proposerIndexProof,\n        bytes32[] calldata pubkeyProof\n    )\n        external\n        nonReentrant\n    {\n        bytes32 beaconBlockRoot = _processTimestampInBuffer(nextTimestamp);\n        _verifyProposerIndexInBeaconBlock(beaconBlockRoot, proposerIndexProof, proposerIndex);\n        _verifyValidatorPubkeyInBeaconBlock(beaconBlockRoot, pubkeyProof, pubkey, proposerIndex);\n        _distributeFor(pubkey, nextTimestamp);\n    }"
  ],
  "Distributor._distributeFor": [
    "function _distributeFor(bytes calldata pubkey, uint64 nextTimestamp) internal {\n        uint256 rewardRate = blockRewardController.processRewards(pubkey, nextTimestamp, beraChef.isReady());\n        if (rewardRate == 0) {\n            return;\n        }\n        beraChef.activateReadyQueuedRewardAllocation(pubkey);\n        IBeraChef.RewardAllocation memory ra = beraChef.getActiveRewardAllocation(pubkey);\n        uint256 totalRewardDistributed;\n        IBeraChef.Weight[] memory weights = ra.weights;\n        uint256 length = weights.length;\n        for (uint256 i; i < length;) {\n            IBeraChef.Weight memory weight = weights[i];\n            address receiver = weight.receiver;\n            uint256 rewardAmount;\n            if (i == length - 1) {\n                rewardAmount = rewardRate - totalRewardDistributed;\n            } else {\n                rewardAmount =\n                    FixedPointMathLib.fullMulDiv(rewardRate, weight.percentageNumerator, ONE_HUNDRED_PERCENT);\n                totalRewardDistributed += rewardAmount;\n            }\n            bgt.safeIncreaseAllowance(receiver, rewardAmount);\n            IRewardVault(receiver).notifyRewardAmount(pubkey, rewardAmount);\n            emit Distributed(pubkey, nextTimestamp, receiver, rewardAmount);\n            unchecked {\n                ++i;\n            }\n        }\n    }"
  ],
  "RewardVaultFactory.initialize": [
    "function initialize(\n        address _bgt,\n        address _distributor,\n        address _beaconDepositContract,\n        address _governance,\n        address _vaultImpl\n    )\n        external\n        initializer\n    {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, _governance);\n        _setRoleAdmin(VAULT_PAUSER_ROLE, VAULT_MANAGER_ROLE);\n        bgt = _bgt;\n        distributor = _distributor;\n        beaconDepositContract = _beaconDepositContract;\n        beacon = address(new UpgradeableBeacon(_governance, _vaultImpl));\n    }"
  ],
  "RewardVaultFactory._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "RewardVaultFactory.setBGTIncentiveDistributor": [
    "function setBGTIncentiveDistributor(address _bgtIncentiveDistributor) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_bgtIncentiveDistributor == address(0)) ZeroAddress.selector.revertWith();\n        emit BGTIncentiveDistributorSet(_bgtIncentiveDistributor, bgtIncentiveDistributor);\n        bgtIncentiveDistributor = _bgtIncentiveDistributor;\n    }"
  ],
  "RewardVaultFactory.createRewardVault": [
    "function createRewardVault(address stakingToken) external returns (address) {\n        address cachedAddress = getVault[stakingToken];\n        if (cachedAddress != address(0)) return cachedAddress;\n        if (stakingToken.code.length == 0) NotAContract.selector.revertWith();\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            mstore(0, stakingToken)\n            salt := keccak256(0, 0x20)\n        }\n        address vault = LibClone.deployDeterministicERC1967BeaconProxy(beacon, salt);\n        getVault[stakingToken] = vault;\n        allVaults.push(vault);\n        emit VaultCreated(stakingToken, vault);\n        RewardVault(vault).initialize(beaconDepositContract, bgt, distributor, stakingToken);\n        return vault;\n    }"
  ],
  "RewardVaultFactory.predictRewardVaultAddress": [
    "function predictRewardVaultAddress(address stakingToken) external view returns (address) {\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            mstore(0, stakingToken)\n            salt := keccak256(0, 0x20)\n        }\n        return LibClone.predictDeterministicAddressERC1967BeaconProxy(beacon, salt, address(this));\n    }"
  ],
  "RewardVaultFactory.allVaultsLength": [
    "function allVaultsLength() external view returns (uint256) {\n        return allVaults.length;\n    }"
  ],
  "IBGT.staker": [
    "function staker() external view returns (address);"
  ],
  "IBGT.activateBoostDelay": [
    "function activateBoostDelay() external view returns (uint32);"
  ],
  "IBGT.dropBoostDelay": [
    "function dropBoostDelay() external view returns (uint32);"
  ],
  "IBGT.whitelistSender": [
    "function whitelistSender(address sender, bool approved) external;"
  ],
  "IBGT.mint": [
    "function mint(address distributor, uint256 amount) external;"
  ],
  "IBGT.queueBoost": [
    "function queueBoost(bytes calldata pubkey, uint128 amount) external;"
  ],
  "IBGT.cancelBoost": [
    "function cancelBoost(bytes calldata pubkey, uint128 amount) external;"
  ],
  "IBGT.activateBoost": [
    "function activateBoost(address user, bytes calldata pubkey) external returns (bool);"
  ],
  "IBGT.queueDropBoost": [
    "function queueDropBoost(bytes calldata pubkey, uint128 amount) external;"
  ],
  "IBGT.cancelDropBoost": [
    "function cancelDropBoost(bytes calldata pubkey, uint128 amount) external;"
  ],
  "IBGT.dropBoost": [
    "function dropBoost(address user, bytes calldata pubkey) external returns (bool);"
  ],
  "IBGT.boostedQueue": [
    "function boostedQueue(\n        address account,\n        bytes calldata pubkey\n    )\n        external\n        view\n        returns (uint32 blockNumberLast, uint128 balance);"
  ],
  "IBGT.dropBoostQueue": [
    "function dropBoostQueue(\n        address account,\n        bytes calldata pubkey\n    )\n        external\n        view\n        returns (uint32 blockNumberLast, uint128 balance);"
  ],
  "IBGT.queuedBoost": [
    "function queuedBoost(address account) external view returns (uint128);"
  ],
  "IBGT.boosted": [
    "function boosted(address account, bytes calldata pubkey) external view returns (uint128);"
  ],
  "IBGT.boosts": [
    "function boosts(address account) external view returns (uint128);"
  ],
  "IBGT.boostees": [
    "function boostees(bytes calldata pubkey) external view returns (uint128);"
  ],
  "IBGT.totalBoosts": [
    "function totalBoosts() external view returns (uint128);"
  ],
  "IBGT.normalizedBoost": [
    "function normalizedBoost(bytes calldata pubkey) external view returns (uint256);"
  ],
  "IBGT.minter": [
    "function minter() external view returns (address);"
  ],
  "IBGT.setMinter": [
    "function setMinter(address _minter) external;"
  ],
  "IBGT.setStaker": [
    "function setStaker(address _staker) external;"
  ],
  "IBGT.setActivateBoostDelay": [
    "function setActivateBoostDelay(uint32 _activateBoostDelay) external;"
  ],
  "IBGT.setDropBoostDelay": [
    "function setDropBoostDelay(uint32 _dropBoostDelay) external;"
  ],
  "IBGT.redeem": [
    "function redeem(address receiver, uint256 amount) external;"
  ],
  "IBGT.unboostedBalanceOf": [
    "function unboostedBalanceOf(address account) external view returns (uint256);"
  ],
  "IBGT.burnExceedingReserves": [
    "function burnExceedingReserves() external;"
  ],
  "IRewardVaultFactory.setBGTIncentiveDistributor": [
    "function setBGTIncentiveDistributor(address _bgtIncentiveDistributor) external;"
  ],
  "IRewardVaultFactory.createRewardVault": [
    "function createRewardVault(address stakingToken) external returns (address);"
  ],
  "IRewardVaultFactory.VAULT_MANAGER_ROLE": [
    "function VAULT_MANAGER_ROLE() external view returns (bytes32);"
  ],
  "IRewardVaultFactory.VAULT_PAUSER_ROLE": [
    "function VAULT_PAUSER_ROLE() external view returns (bytes32);"
  ],
  "IRewardVaultFactory.getVault": [
    "function getVault(address stakingToken) external view returns (address);"
  ],
  "IRewardVaultFactory.allVaultsLength": [
    "function allVaultsLength() external view returns (uint256);"
  ],
  "IRewardVaultFactory.bgtIncentiveDistributor": [
    "function bgtIncentiveDistributor() external view returns (address);"
  ],
  "IRewardVaultFactory.predictRewardVaultAddress": [
    "function predictRewardVaultAddress(address stakingToken) external view returns (address);"
  ],
  "IBGTStaker.notifyRewardAmount": [
    "function notifyRewardAmount(uint256 reward) external;"
  ],
  "IBGTStaker.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external;"
  ],
  "IBGTStaker.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external;"
  ],
  "IBGTStaker.stake": [
    "function stake(address account, uint256 amount) external;"
  ],
  "IBGTStaker.withdraw": [
    "function withdraw(address account, uint256 amount) external;"
  ],
  "IBGTStaker.getReward": [
    "function getReward() external returns (uint256);"
  ],
  "IBeaconDeposit.getOperator": [
    "function getOperator(bytes calldata pubkey) external view returns (address);"
  ],
  "IBeaconDeposit.deposit": [
    "function deposit(\n        bytes calldata pubkey,\n        bytes calldata credentials,\n        bytes calldata signature,\n        address operator\n    )\n        external\n        payable;"
  ],
  "IBeaconDeposit.requestOperatorChange": [
    "function requestOperatorChange(bytes calldata pubkey, address newOperator) external;"
  ],
  "IBeaconDeposit.cancelOperatorChange": [
    "function cancelOperatorChange(bytes calldata pubkey) external;"
  ],
  "IBeaconDeposit.acceptOperatorChange": [
    "function acceptOperatorChange(bytes calldata pubkey) external;"
  ],
  "IRewardVault.distributor": [
    "function distributor() external view returns (address);"
  ],
  "IRewardVault.operator": [
    "function operator(address account) external view returns (address);"
  ],
  "IRewardVault.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256);"
  ],
  "IRewardVault.getWhitelistedTokens": [
    "function getWhitelistedTokens() external view returns (address[] memory);"
  ],
  "IRewardVault.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256);"
  ],
  "IRewardVault.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256);"
  ],
  "IRewardVault.initialize": [
    "function initialize(address _berachef, address _bgt, address _distributor, address _stakingToken) external;"
  ],
  "IRewardVault.setDistributor": [
    "function setDistributor(address _rewardDistribution) external;"
  ],
  "IRewardVault.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external;"
  ],
  "IRewardVault.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external;"
  ],
  "IRewardVault.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external;"
  ],
  "IRewardVault.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(address token, uint256 minIncentiveRate, address manager) external;"
  ],
  "IRewardVault.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external;"
  ],
  "IRewardVault.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external;"
  ],
  "IRewardVault.pause": [
    "function pause() external;"
  ],
  "IRewardVault.unpause": [
    "function unpause() external;"
  ],
  "IRewardVault.exit": [
    "function exit(address recipient) external;"
  ],
  "IRewardVault.getReward": [
    "function getReward(address account, address recipient) external returns (uint256);"
  ],
  "IRewardVault.stake": [
    "function stake(uint256 amount) external;"
  ],
  "IRewardVault.delegateStake": [
    "function delegateStake(address account, uint256 amount) external;"
  ],
  "IRewardVault.withdraw": [
    "function withdraw(uint256 amount) external;"
  ],
  "IRewardVault.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external;"
  ],
  "IRewardVault.setOperator": [
    "function setOperator(address _operator) external;"
  ],
  "IRewardVault.updateIncentiveManager": [
    "function updateIncentiveManager(address token, address newManager) external;"
  ],
  "IRewardVault.addIncentive": [
    "function addIncentive(address token, uint256 amount, uint256 incentiveRate) external;"
  ],
  "IRewardVault.accountIncentives": [
    "function accountIncentives(address token, uint256 amount) external;"
  ],
  "IFeeCollector.queuePayoutAmountChange": [
    "function queuePayoutAmountChange(uint256 _newPayoutAmount) external;"
  ],
  "IFeeCollector.payoutToken": [
    "function payoutToken() external view returns (address);"
  ],
  "IFeeCollector.queuedPayoutAmount": [
    "function queuedPayoutAmount() external view returns (uint256);"
  ],
  "IFeeCollector.payoutAmount": [
    "function payoutAmount() external view returns (uint256);"
  ],
  "IFeeCollector.rewardReceiver": [
    "function rewardReceiver() external view returns (address);"
  ],
  "IFeeCollector.claimFees": [
    "function claimFees(address recipient, address[] calldata feeTokens) external;"
  ],
  "IFeeCollector.donate": [
    "function donate(uint256 amount) external;"
  ],
  "IFeeCollector.pause": [
    "function pause() external;"
  ],
  "IFeeCollector.unpause": [
    "function unpause() external;"
  ],
  "IBeraChef.getActiveRewardAllocation": [
    "function getActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef.getQueuedRewardAllocation": [
    "function getQueuedRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef.getSetActiveRewardAllocation": [
    "function getSetActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef.getDefaultRewardAllocation": [
    "function getDefaultRewardAllocation() external view returns (RewardAllocation memory);"
  ],
  "IBeraChef.isQueuedRewardAllocationReady": [
    "function isQueuedRewardAllocationReady(\n        bytes calldata valPubkey,\n        uint256 blockNumber\n    )\n        external\n        view\n        returns (bool);"
  ],
  "IBeraChef.isReady": [
    "function isReady() external view returns (bool);"
  ],
  "IBeraChef.getValQueuedCommissionOnIncentiveTokens": [
    "function getValQueuedCommissionOnIncentiveTokens(bytes calldata valPubkey)\n        external\n        view\n        returns (QueuedCommissionRateChange memory);"
  ],
  "IBeraChef.getValCommissionOnIncentiveTokens": [
    "function getValCommissionOnIncentiveTokens(bytes calldata valPubkey) external view returns (uint96);"
  ],
  "IBeraChef.getValidatorIncentiveTokenShare": [
    "function getValidatorIncentiveTokenShare(\n        bytes calldata valPubkey,\n        uint256 incentiveTokenAmount\n    )\n        external\n        view\n        returns (uint256);"
  ],
  "IBeraChef.setMaxNumWeightsPerRewardAllocation": [
    "function setMaxNumWeightsPerRewardAllocation(uint8 _maxNumWeightsPerRewardAllocation) external;"
  ],
  "IBeraChef.setMaxWeightPerVault": [
    "function setMaxWeightPerVault(uint96 _maxWeightPerVault) external;"
  ],
  "IBeraChef.setRewardAllocationBlockDelay": [
    "function setRewardAllocationBlockDelay(uint64 _rewardAllocationBlockDelay) external;"
  ],
  "IBeraChef.setVaultWhitelistedStatus": [
    "function setVaultWhitelistedStatus(address receiver, bool isWhitelisted, string memory metadata) external;"
  ],
  "IBeraChef.updateWhitelistedVaultMetadata": [
    "function updateWhitelistedVaultMetadata(address receiver, string memory metadata) external;"
  ],
  "IBeraChef.setDefaultRewardAllocation": [
    "function setDefaultRewardAllocation(RewardAllocation calldata rewardAllocation) external;"
  ],
  "IBeraChef.queueNewRewardAllocation": [
    "function queueNewRewardAllocation(\n        bytes calldata valPubkey,\n        uint64 startBlock,\n        Weight[] calldata weights\n    )\n        external;"
  ],
  "IBeraChef.activateReadyQueuedRewardAllocation": [
    "function activateReadyQueuedRewardAllocation(bytes calldata valPubkey) external;"
  ],
  "IBeraChef.setCommissionChangeDelay": [
    "function setCommissionChangeDelay(uint64 _commissionChangeDelay) external;"
  ],
  "IBeraChef.queueValCommission": [
    "function queueValCommission(bytes calldata valPubkey, uint96 commissionRate) external;"
  ],
  "IBeraChef.activateQueuedValCommission": [
    "function activateQueuedValCommission(bytes calldata valPubkey) external;"
  ],
  "IBGTIncentiveDistributor.incentiveTokensPerValidator": [
    "function incentiveTokensPerValidator(bytes calldata pubkey, address token) external view returns (uint256);"
  ],
  "IBGTIncentiveDistributor.setRewardClaimDelay": [
    "function setRewardClaimDelay(uint64 _delay) external;"
  ],
  "IBGTIncentiveDistributor.receiveIncentive": [
    "function receiveIncentive(bytes calldata pubkey, address token, uint256 _amount) external;"
  ],
  "IBGTIncentiveDistributor.claim": [
    "function claim(Claim[] calldata _claims) external;"
  ],
  "IBGTIncentiveDistributor.setPauseState": [
    "function setPauseState(bool state) external;"
  ],
  "IBGTIncentiveDistributor.updateRewardsMetadata": [
    "function updateRewardsMetadata(Distribution[] calldata _distributions) external;"
  ],
  "IDistributor.distributeFor": [
    "function distributeFor(\n        uint64 nextTimestamp,\n        uint64 proposerIndex,\n        bytes calldata pubkey,\n        bytes32[] calldata proposerIndexProof,\n        bytes32[] calldata pubkeyProof\n    )\n        external;"
  ],
  "IDistributor.beraChef": [
    "function beraChef() external view returns (IBeraChef);"
  ],
  "ERC165.supportsInterface": [
    "function supportsInterface(bytes4 interfaceId) external pure returns (bool);"
  ],
  "IBlockRewardController.baseRate": [
    "function baseRate() external view returns (uint256);"
  ],
  "IBlockRewardController.rewardRate": [
    "function rewardRate() external view returns (uint256);"
  ],
  "IBlockRewardController.minBoostedRewardRate": [
    "function minBoostedRewardRate() external view returns (uint256);"
  ],
  "IBlockRewardController.boostMultiplier": [
    "function boostMultiplier() external view returns (uint256);"
  ],
  "IBlockRewardController.rewardConvexity": [
    "function rewardConvexity() external view returns (int256);"
  ],
  "IBlockRewardController.computeReward": [
    "function computeReward(\n        uint256 boostPower,\n        uint256 _rewardRate,\n        uint256 _boostMultiplier,\n        int256 _rewardConvexity\n    )\n        external\n        pure\n        returns (uint256);"
  ],
  "IBlockRewardController.getMaxBGTPerBlock": [
    "function getMaxBGTPerBlock() external view returns (uint256 amount);"
  ],
  "IBlockRewardController.processRewards": [
    "function processRewards(bytes calldata pubkey, uint64 nextTimestamp, bool isReady) external returns (uint256);"
  ],
  "IBlockRewardController.setBaseRate": [
    "function setBaseRate(uint256 _baseRate) external;"
  ],
  "IBlockRewardController.setRewardRate": [
    "function setRewardRate(uint256 _rewardRate) external;"
  ],
  "IBlockRewardController.setMinBoostedRewardRate": [
    "function setMinBoostedRewardRate(uint256 _minBoostedRewardRate) external;"
  ],
  "IBlockRewardController.setBoostMultiplier": [
    "function setBoostMultiplier(uint256 _boostMultiplier) external;"
  ],
  "IBlockRewardController.setRewardConvexity": [
    "function setRewardConvexity(uint256 _rewardConvexity) external;"
  ],
  "IBlockRewardController.setDistributor": [
    "function setDistributor(address _distributor) external;"
  ],
  "RewardVault_V2.initialize": [
    "function initialize(\n        address _beaconDepositContract,\n        address _bgt,\n        address _distributor,\n        address _stakingToken\n    )\n        external\n        initializer\n    {\n        __FactoryOwnable_init(msg.sender);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __StakingRewards_init(_stakingToken, _bgt, 3 days);\n        maxIncentiveTokensCount = 2;\n        distributor = _distributor;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        emit DistributorSet(_distributor);\n        emit MaxIncentiveTokensCountUpdated(2);\n    }"
  ],
  "RewardVault_V2.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) NotDistributor.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V2.onlyOperatorOrUser": [
    "modifier onlyOperatorOrUser(address account) {\n        if (msg.sender != account) {\n            if (msg.sender != _operators[account]) NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "RewardVault_V2.checkSelfStakedBalance": [
    "modifier checkSelfStakedBalance(address account, uint256 amount) {\n        _checkSelfStakedBalance(account, amount);\n        _;\n    }"
  ],
  "RewardVault_V2.onlyWhitelistedToken": [
    "modifier onlyWhitelistedToken(address token) {\n        if (incentives[token].minIncentiveRate == 0) TokenNotWhitelisted.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V2.setDistributor": [
    "function setDistributor(address _rewardDistribution) external onlyFactoryOwner {\n        if (_rewardDistribution == address(0)) ZeroAddress.selector.revertWith();\n        distributor = _rewardDistribution;\n        emit DistributorSet(_rewardDistribution);\n    }"
  ],
  "RewardVault_V2.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external onlyDistributor {\n        _notifyRewardAmount(reward);\n        _processIncentives(pubkey, reward);\n    }"
  ],
  "RewardVault_V2.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyFactoryOwner {\n        if (tokenAddress == address(stakeToken)) CannotRecoverStakingToken.selector.revertWith();\n        if (incentives[tokenAddress].minIncentiveRate != 0) CannotRecoverIncentiveToken.selector.revertWith();\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }"
  ],
  "RewardVault_V2.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external onlyFactoryOwner {\n        _setRewardsDuration(_rewardsDuration);\n    }"
  ],
  "RewardVault_V2.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(\n        address token,\n        uint256 minIncentiveRate,\n        address manager\n    )\n        external\n        onlyFactoryOwner\n    {\n        if (minIncentiveRate == 0) MinIncentiveRateIsZero.selector.revertWith();\n        if (minIncentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        if (token == address(0) || manager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        if (whitelistedTokens.length == maxIncentiveTokensCount || incentive.minIncentiveRate != 0) {\n            TokenAlreadyWhitelistedOrLimitReached.selector.revertWith();\n        }\n        whitelistedTokens.push(token);\n        incentive.incentiveRate = minIncentiveRate;\n        incentive.minIncentiveRate = minIncentiveRate;\n        incentive.manager = manager;\n        emit IncentiveTokenWhitelisted(token, minIncentiveRate, manager);\n    }"
  ],
  "RewardVault_V2.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external onlyFactoryVaultManager onlyWhitelistedToken(token) {\n        delete incentives[token];\n        _deleteWhitelistedTokenFromList(token);\n        emit IncentiveTokenRemoved(token);\n    }"
  ],
  "RewardVault_V2.updateIncentiveManager": [
    "function updateIncentiveManager(\n        address token,\n        address newManager\n    )\n        external\n        onlyFactoryOwner\n        onlyWhitelistedToken(token)\n    {\n        if (newManager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        address currentManager = incentive.manager;\n        incentive.manager = newManager;\n        emit IncentiveManagerChanged(token, newManager, currentManager);\n    }"
  ],
  "RewardVault_V2.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external onlyFactoryOwner {\n        if (_maxIncentiveTokensCount < whitelistedTokens.length) {\n            InvalidMaxIncentiveTokensCount.selector.revertWith();\n        }\n        maxIncentiveTokensCount = _maxIncentiveTokensCount;\n        emit MaxIncentiveTokensCountUpdated(_maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault_V2.pause": [
    "function pause() external onlyFactoryVaultPauser {\n        _pause();\n    }"
  ],
  "RewardVault_V2.unpause": [
    "function unpause() external onlyFactoryVaultManager {\n        _unpause();\n    }"
  ],
  "RewardVault_V2.operator": [
    "function operator(address account) external view returns (address) {\n        return _operators[account];\n    }"
  ],
  "RewardVault_V2.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256) {\n        return whitelistedTokens.length;\n    }"
  ],
  "RewardVault_V2.getWhitelistedTokens": [
    "function getWhitelistedTokens() public view returns (address[] memory) {\n        return whitelistedTokens;\n    }"
  ],
  "RewardVault_V2.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256) {\n        return _delegateStake[account].delegateTotalStaked;\n    }"
  ],
  "RewardVault_V2.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256) {\n        return _delegateStake[account].stakedByDelegate[delegate];\n    }"
  ],
  "RewardVault_V2.stake": [
    "function stake(uint256 amount) external nonReentrant whenNotPaused {\n        _stake(msg.sender, amount);\n    }"
  ],
  "RewardVault_V2.delegateStake": [
    "function delegateStake(address account, uint256 amount) external nonReentrant whenNotPaused {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        _stake(account, amount);\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            info.delegateTotalStaked += amount;\n            info.stakedByDelegate[msg.sender] += amount;\n        }\n        emit DelegateStaked(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V2.withdraw": [
    "function withdraw(uint256 amount) external nonReentrant checkSelfStakedBalance(msg.sender, amount) {\n        _withdraw(msg.sender, amount);\n    }"
  ],
  "RewardVault_V2.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external nonReentrant {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            uint256 stakedByDelegate = info.stakedByDelegate[msg.sender];\n            if (stakedByDelegate < amount) InsufficientDelegateStake.selector.revertWith();\n            info.stakedByDelegate[msg.sender] = stakedByDelegate - amount;\n            info.delegateTotalStaked -= amount;\n        }\n        _withdraw(account, amount);\n        emit DelegateWithdrawn(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V2.getReward": [
    "function getReward(\n        address account,\n        address recipient\n    )\n        external\n        nonReentrant\n        onlyOperatorOrUser(account)\n        returns (uint256)\n    {\n        return _getReward(account, recipient);\n    }"
  ],
  "RewardVault_V2.exit": [
    "function exit(address recipient) external nonReentrant {\n        uint256 amount = _accountInfo[msg.sender].balance - _delegateStake[msg.sender].delegateTotalStaked;\n        _withdraw(msg.sender, amount);\n        _getReward(msg.sender, recipient);\n    }"
  ],
  "RewardVault_V2.setOperator": [
    "function setOperator(address _operator) external {\n        _operators[msg.sender] = _operator;\n        emit OperatorSet(msg.sender, _operator);\n    }"
  ],
  "RewardVault_V2.addIncentive": [
    "function addIncentive(\n        address token,\n        uint256 amount,\n        uint256 incentiveRate\n    )\n        external\n        nonReentrant\n        onlyWhitelistedToken(token)\n    {\n        if (incentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        incentive.amountRemaining = amountRemainingBefore + amount;\n        if (amountRemainingBefore == 0 && incentiveRate >= minIncentiveRate) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else if (incentiveRate > incentiveRateStored) {\n            uint256 rateDelta;\n            unchecked {\n                rateDelta = incentiveRate - incentiveRateStored;\n            }\n            if (amount >= FixedPointMathLib.mulDiv(amountRemainingBefore, rateDelta, incentiveRateStored)) {\n                incentive.incentiveRate = incentiveRate;\n            }\n        }\n        emit IncentiveAdded(token, msg.sender, amount, incentive.incentiveRate);\n    }"
  ],
  "RewardVault_V2._checkSelfStakedBalance": [
    "function _checkSelfStakedBalance(address account, uint256 amount) internal view {\n        unchecked {\n            uint256 selfStaked = _accountInfo[account].balance - _delegateStake[account].delegateTotalStaked;\n            if (selfStaked < amount) InsufficientSelfStake.selector.revertWith();\n        }\n    }"
  ],
  "RewardVault_V2._safeTransferRewardToken": [
    "function _safeTransferRewardToken(address to, uint256 amount) internal override {\n        rewardToken.safeTransferFrom(distributor, to, amount);\n    }"
  ],
  "RewardVault_V2._checkRewardSolvency": [
    "function _checkRewardSolvency() internal view override {\n        uint256 allowance = rewardToken.allowance(distributor, address(this));\n        if (undistributedRewards / PRECISION > allowance) InsolventReward.selector.revertWith();\n    }"
  ],
  "RewardVault_V2._processIncentives": [
    "function _processIncentives(bytes calldata pubkey, uint256 bgtEmitted) internal {\n        address _operator = beaconDepositContract.getOperator(pubkey);\n        IBeraChef beraChef = IDistributor(distributor).beraChef();\n        address bgtIncentiveDistributor = getBGTIncentiveDistributor();\n        uint256 whitelistedTokensCount = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < whitelistedTokensCount; ++i) {\n                address token = whitelistedTokens[i];\n                Incentive storage incentive = incentives[token];\n                uint256 amount = FixedPointMathLib.mulDiv(bgtEmitted, incentive.incentiveRate, PRECISION);\n                uint256 amountRemaining = incentive.amountRemaining;\n                amount = FixedPointMathLib.min(amount, amountRemaining);\n                uint256 validatorShare;\n                if (amount > 0) {\n                    validatorShare = beraChef.getValidatorIncentiveTokenShare(pubkey, amount);\n                    amount -= validatorShare;\n                }\n                if (validatorShare > 0) {\n                    bool success = token.trySafeTransfer(_operator, validatorShare);\n                    if (success) {\n                        amountRemaining -= validatorShare;\n                        emit IncentivesProcessed(pubkey, token, bgtEmitted, validatorShare);\n                    } else {\n                        emit IncentivesProcessFailed(pubkey, token, bgtEmitted, validatorShare);\n                    }\n                }\n                if (amount > 0) {\n                    bytes memory data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, amount));\n                    (bool success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                    if (success) {\n                        data = abi.encodeCall(IBGTIncentiveDistributor.receiveIncentive, (pubkey, token, amount));\n                        (success,) = bgtIncentiveDistributor.call{ gas: SAFE_GAS_LIMIT }(data);\n                        if (success) {\n                            amountRemaining -= amount;\n                            emit BGTBoosterIncentivesProcessed(pubkey, token, bgtEmitted, amount);\n                        } else {\n                            data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, 0));\n                            (success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                            emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                        }\n                    }\n                    else {\n                        emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                    }\n                }\n                incentive.amountRemaining = amountRemaining;\n            }\n        }\n    }"
  ],
  "RewardVault_V2._deleteWhitelistedTokenFromList": [
    "function _deleteWhitelistedTokenFromList(address token) internal {\n        uint256 activeTokens = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < activeTokens; ++i) {\n                if (token == whitelistedTokens[i]) {\n                    whitelistedTokens[i] = whitelistedTokens[activeTokens - 1];\n                    whitelistedTokens.pop();\n                    return;\n                }\n            }\n        }\n    }"
  ],
  "SSZ.validatorPubkeyHashTreeRoot": [
    "function validatorPubkeyHashTreeRoot(bytes memory pubkey) internal view returns (bytes32 root) {\n        if (pubkey.length != VALIDATOR_PUBKEY_LENGTH) {\n            InvalidValidatorPubkeyLength.selector.revertWith();\n        }\n        assembly (\"memory-safe\") {\n            let result := staticcall(gas(), SHA256, add(pubkey, 32), 0x40, 0x00, 0x20)\n            if eq(result, 0) { revert(0, 0) }\n            root := mload(0x00)\n        }\n    }"
  ],
  "SSZ.addressHashTreeRoot": [
    "function addressHashTreeRoot(address v) internal pure returns (bytes32 root) {\n        return bytes32(bytes20(v));\n    }"
  ],
  "SSZ.uint64HashTreeRoot": [
    "function uint64HashTreeRoot(uint64 v) internal pure returns (bytes32) {\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) | ((v & 0x00FF00FF00FF00FF) << 8);\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) | ((v & 0x0000FFFF0000FFFF) << 16);\n        v = (v >> 32) | (v << 32);\n        return bytes32(uint256(v) << 192);\n    }"
  ],
  "SSZ.verifyProof": [
    "function verifyProof(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    )\n        internal\n        view\n        returns (bool isValid)\n    {\n        assembly (\"memory-safe\") {\n            if proof.length {\n                let end := add(proof.offset, shl(5, proof.length))\n                let offset := proof.offset\n                for { } 1 { } {\n                    let scratch := shl(5, and(index, 1))\n                    index := shr(1, index)\n                    if iszero(index) {\n                        mstore(0x00, 0x5849603f)\n                        revert(0x1c, 0x04)\n                    }\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    let result := staticcall(gas(), SHA256, 0x00, 0x40, 0x00, 0x20)\n                    if eq(result, 0) { revert(0, 0) }\n                    leaf := mload(0x00)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            if gt(sub(index, 1), 0) {\n                mstore(0x00, 0x1b6661c3)\n                revert(0x1c, 0x04)\n            }\n            isValid := eq(leaf, root)\n        }\n    }"
  ],
  "BeaconRoots.isParentBlockRootAt": [
    "function isParentBlockRootAt(uint64 ts) internal view returns (bool success) {\n        assembly (\"memory-safe\") {\n            mstore(0, ts)\n            success := staticcall(gas(), ADDRESS, 0, 0x20, 0, 0x20)\n        }\n    }"
  ],
  "BeaconRoots.getParentBlockRootAt": [
    "function getParentBlockRootAt(uint64 ts) internal view returns (bytes32 root) {\n        assembly (\"memory-safe\") {\n            mstore(0, ts)\n            let success := staticcall(gas(), ADDRESS, 0, 0x20, 0, 0x20)\n            if iszero(success) {\n                mstore(0, 0x3033b0ff) \n                revert(0x1c, 0x04)\n            }\n            root := mload(0)\n        }\n    }"
  ],
  "Utils.revertWith": [
    "function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }",
    "function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, addr)\n            revert(0, 0x24) \n        }\n    }",
    "function revertWith(bytes4 selector, uint256 amount) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, amount)\n            revert(0, 0x24) \n        }\n    }",
    "function revertWith(bytes4 selector, uint256 amount1, uint256 amount2) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, amount1)\n            mstore(0x24, amount2)\n            revert(0, 0x44) \n        }\n    }",
    "function revertWith(bytes4 selector, address addr1, address addr2) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, addr1)\n            mstore(0x24, addr2)\n            revert(0, 0x44) \n        }\n    }"
  ],
  "Utils.revertFor": [
    "function revertFor(bytes memory reason) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(reason, 0x20), mload(reason))\n        }\n    }"
  ],
  "Utils.safeIncreaseAllowance": [
    "function safeIncreaseAllowance(address token, address spender, uint256 amount) internal {\n        unchecked {\n            uint256 oldAllowance = allowance(token, address(this), spender);\n            uint256 newAllowance = oldAllowance + amount;\n            if (newAllowance < oldAllowance) revertWith(IncreaseAllowanceOverflow.selector);\n            token.safeApprove(spender, newAllowance);\n        }\n    }"
  ],
  "Utils.allowance": [
    "function allowance(address token, address owner, address spender) internal view returns (uint256 amount) {\n        assembly (\"memory-safe\") {\n            mstore(0, 0xdd62ed3e00000000000000000000000000000000000000000000000000000000) \n            mstore(0x04, owner) \n            mstore(0x24, spender) \n            amount :=\n                mul( \n                    mload(0),\n                    and( \n                        gt(returndatasize(), 0x1f), \n                        staticcall(gas(), token, 0, 0x44, 0, 0x20)\n                    )\n                )\n            mstore(0x24, 0) \n        }\n    }"
  ],
  "Utils.trySafeTransfer": [
    "function trySafeTransfer(address token, address to, uint256 amount) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            mstore(0x14, to) \n            mstore(0x34, amount) \n            mstore(0x00, 0xa9059cbb000000000000000000000000) \n            success :=\n                and(\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), \n                    call(TRANSFER_GAS_LIMIT, token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            mstore(0x34, 0) \n        }\n    }"
  ],
  "Utils.changeDecimals": [
    "function changeDecimals(uint256 amount, uint8 from, uint8 to) internal pure returns (uint256) {\n        if (from == to) {\n            return amount;\n        }\n        if (from > to) {\n            return amount / (10 ** (from - to));\n        } else {\n            return amount * (10 ** (to - from));\n        }\n    }"
  ],
  "RewardVault_V3.initialize": [
    "function initialize(\n        address _beaconDepositContract,\n        address _bgt,\n        address _distributor,\n        address _stakingToken\n    )\n        external\n        initializer\n    {\n        __FactoryOwnable_init(msg.sender);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __StakingRewards_init(_stakingToken, _bgt, 3 days);\n        maxIncentiveTokensCount = 2;\n        distributor = _distributor;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        emit DistributorSet(_distributor);\n        emit MaxIncentiveTokensCountUpdated(2);\n    }"
  ],
  "RewardVault_V3.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) NotDistributor.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V3.onlyOperatorOrUser": [
    "modifier onlyOperatorOrUser(address account) {\n        if (msg.sender != account) {\n            if (msg.sender != _operators[account]) NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "RewardVault_V3.checkSelfStakedBalance": [
    "modifier checkSelfStakedBalance(address account, uint256 amount) {\n        _checkSelfStakedBalance(account, amount);\n        _;\n    }"
  ],
  "RewardVault_V3.onlyWhitelistedToken": [
    "modifier onlyWhitelistedToken(address token) {\n        if (incentives[token].minIncentiveRate == 0) TokenNotWhitelisted.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V3.setDistributor": [
    "function setDistributor(address _rewardDistribution) external onlyFactoryOwner {\n        if (_rewardDistribution == address(0)) ZeroAddress.selector.revertWith();\n        distributor = _rewardDistribution;\n        emit DistributorSet(_rewardDistribution);\n    }"
  ],
  "RewardVault_V3.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external onlyDistributor {\n        _notifyRewardAmount(reward);\n        _processIncentives(pubkey, reward);\n    }"
  ],
  "RewardVault_V3.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyFactoryOwner {\n        if (tokenAddress == address(stakeToken)) CannotRecoverStakingToken.selector.revertWith();\n        if (incentives[tokenAddress].minIncentiveRate != 0) CannotRecoverIncentiveToken.selector.revertWith();\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }"
  ],
  "RewardVault_V3.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external onlyFactoryOwner {\n        _setRewardsDuration(_rewardsDuration);\n    }"
  ],
  "RewardVault_V3.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(\n        address token,\n        uint256 minIncentiveRate,\n        address manager\n    )\n        external\n        onlyFactoryOwner\n    {\n        if (minIncentiveRate == 0) MinIncentiveRateIsZero.selector.revertWith();\n        if (minIncentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        if (token == address(0) || manager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        if (whitelistedTokens.length == maxIncentiveTokensCount || incentive.minIncentiveRate != 0) {\n            TokenAlreadyWhitelistedOrLimitReached.selector.revertWith();\n        }\n        whitelistedTokens.push(token);\n        incentive.incentiveRate = minIncentiveRate;\n        incentive.minIncentiveRate = minIncentiveRate;\n        incentive.manager = manager;\n        emit IncentiveTokenWhitelisted(token, minIncentiveRate, manager);\n    }"
  ],
  "RewardVault_V3.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external onlyFactoryVaultManager onlyWhitelistedToken(token) {\n        delete incentives[token];\n        _deleteWhitelistedTokenFromList(token);\n        emit IncentiveTokenRemoved(token);\n    }"
  ],
  "RewardVault_V3.updateIncentiveManager": [
    "function updateIncentiveManager(\n        address token,\n        address newManager\n    )\n        external\n        onlyFactoryOwner\n        onlyWhitelistedToken(token)\n    {\n        if (newManager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        address currentManager = incentive.manager;\n        incentive.manager = newManager;\n        emit IncentiveManagerChanged(token, newManager, currentManager);\n    }"
  ],
  "RewardVault_V3.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external onlyFactoryOwner {\n        if (_maxIncentiveTokensCount < whitelistedTokens.length) {\n            InvalidMaxIncentiveTokensCount.selector.revertWith();\n        }\n        maxIncentiveTokensCount = _maxIncentiveTokensCount;\n        emit MaxIncentiveTokensCountUpdated(_maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault_V3.pause": [
    "function pause() external onlyFactoryVaultPauser {\n        _pause();\n    }"
  ],
  "RewardVault_V3.unpause": [
    "function unpause() external onlyFactoryVaultManager {\n        _unpause();\n    }"
  ],
  "RewardVault_V3.operator": [
    "function operator(address account) external view returns (address) {\n        return _operators[account];\n    }"
  ],
  "RewardVault_V3.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256) {\n        return whitelistedTokens.length;\n    }"
  ],
  "RewardVault_V3.getWhitelistedTokens": [
    "function getWhitelistedTokens() public view returns (address[] memory) {\n        return whitelistedTokens;\n    }"
  ],
  "RewardVault_V3.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256) {\n        return _delegateStake[account].delegateTotalStaked;\n    }"
  ],
  "RewardVault_V3.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256) {\n        return _delegateStake[account].stakedByDelegate[delegate];\n    }"
  ],
  "RewardVault_V3.stake": [
    "function stake(uint256 amount) external nonReentrant whenNotPaused {\n        _stake(msg.sender, amount);\n    }"
  ],
  "RewardVault_V3.delegateStake": [
    "function delegateStake(address account, uint256 amount) external nonReentrant whenNotPaused {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        _stake(account, amount);\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            info.delegateTotalStaked += amount;\n            info.stakedByDelegate[msg.sender] += amount;\n        }\n        emit DelegateStaked(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V3.withdraw": [
    "function withdraw(uint256 amount) external nonReentrant checkSelfStakedBalance(msg.sender, amount) {\n        _withdraw(msg.sender, amount);\n    }"
  ],
  "RewardVault_V3.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external nonReentrant {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            uint256 stakedByDelegate = info.stakedByDelegate[msg.sender];\n            if (stakedByDelegate < amount) InsufficientDelegateStake.selector.revertWith();\n            info.stakedByDelegate[msg.sender] = stakedByDelegate - amount;\n            info.delegateTotalStaked -= amount;\n        }\n        _withdraw(account, amount);\n        emit DelegateWithdrawn(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V3.getReward": [
    "function getReward(\n        address account,\n        address recipient\n    )\n        external\n        nonReentrant\n        onlyOperatorOrUser(account)\n        returns (uint256)\n    {\n        return _getReward(account, recipient);\n    }"
  ],
  "RewardVault_V3.exit": [
    "function exit(address recipient) external nonReentrant {\n        uint256 amount = _accountInfo[msg.sender].balance - _delegateStake[msg.sender].delegateTotalStaked;\n        _withdraw(msg.sender, amount);\n        _getReward(msg.sender, recipient);\n    }"
  ],
  "RewardVault_V3.setOperator": [
    "function setOperator(address _operator) external {\n        _operators[msg.sender] = _operator;\n        emit OperatorSet(msg.sender, _operator);\n    }"
  ],
  "RewardVault_V3.addIncentive": [
    "function addIncentive(\n        address token,\n        uint256 amount,\n        uint256 incentiveRate\n    )\n        external\n        nonReentrant\n        onlyWhitelistedToken(token)\n    {\n        if (incentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        if (incentiveRate < minIncentiveRate) InvalidIncentiveRate.selector.revertWith();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        incentive.amountRemaining = amountRemainingBefore + amount;\n        if (amountRemainingBefore == 0) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else if (incentiveRate >= incentiveRateStored) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else {\n            InvalidIncentiveRate.selector.revertWith();\n        }\n        emit IncentiveAdded(token, msg.sender, amount, incentive.incentiveRate);\n    }"
  ],
  "RewardVault_V3.accountIncentives": [
    "function accountIncentives(address token, uint256 amount) external nonReentrant onlyWhitelistedToken(token) {\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        uint256 incentiveBalance = IERC20(token).balanceOf(address(this));\n        if (amount > incentiveBalance - amountRemainingBefore) NotEnoughBalance.selector.revertWith();\n        incentive.amountRemaining += amount;\n        emit IncentiveAdded(token, msg.sender, amount, incentiveRateStored);\n    }"
  ],
  "RewardVault_V3._checkSelfStakedBalance": [
    "function _checkSelfStakedBalance(address account, uint256 amount) internal view {\n        unchecked {\n            uint256 selfStaked = _accountInfo[account].balance - _delegateStake[account].delegateTotalStaked;\n            if (selfStaked < amount) InsufficientSelfStake.selector.revertWith();\n        }\n    }"
  ],
  "RewardVault_V3._safeTransferRewardToken": [
    "function _safeTransferRewardToken(address to, uint256 amount) internal override {\n        rewardToken.safeTransferFrom(distributor, to, amount);\n    }"
  ],
  "RewardVault_V3._checkRewardSolvency": [
    "function _checkRewardSolvency() internal view override {\n        uint256 allowance = rewardToken.allowance(distributor, address(this));\n        if (undistributedRewards / PRECISION > allowance) InsolventReward.selector.revertWith();\n    }"
  ],
  "RewardVault_V3._processIncentives": [
    "function _processIncentives(bytes calldata pubkey, uint256 bgtEmitted) internal {\n        address _operator = beaconDepositContract.getOperator(pubkey);\n        IBeraChef beraChef = IDistributor(distributor).beraChef();\n        address bgtIncentiveDistributor = getBGTIncentiveDistributor();\n        uint256 whitelistedTokensCount = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < whitelistedTokensCount; ++i) {\n                address token = whitelistedTokens[i];\n                Incentive storage incentive = incentives[token];\n                uint256 amount = FixedPointMathLib.mulDiv(bgtEmitted, incentive.incentiveRate, PRECISION);\n                uint256 amountRemaining = incentive.amountRemaining;\n                amount = FixedPointMathLib.min(amount, amountRemaining);\n                uint256 validatorShare;\n                if (amount > 0) {\n                    validatorShare = beraChef.getValidatorIncentiveTokenShare(pubkey, amount);\n                    amount -= validatorShare;\n                }\n                if (validatorShare > 0) {\n                    bool success = token.trySafeTransfer(_operator, validatorShare);\n                    if (success) {\n                        amountRemaining -= validatorShare;\n                        emit IncentivesProcessed(pubkey, token, bgtEmitted, validatorShare);\n                    } else {\n                        emit IncentivesProcessFailed(pubkey, token, bgtEmitted, validatorShare);\n                    }\n                }\n                if (amount > 0) {\n                    bytes memory data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, amount));\n                    (bool success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                    if (success) {\n                        data = abi.encodeCall(IBGTIncentiveDistributor.receiveIncentive, (pubkey, token, amount));\n                        (success,) = bgtIncentiveDistributor.call{ gas: SAFE_GAS_LIMIT }(data);\n                        if (success) {\n                            amountRemaining -= amount;\n                            emit BGTBoosterIncentivesProcessed(pubkey, token, bgtEmitted, amount);\n                        } else {\n                            data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, 0));\n                            (success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                            emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                        }\n                    }\n                    else {\n                        emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                    }\n                }\n                incentive.amountRemaining = amountRemaining;\n            }\n        }\n    }"
  ],
  "RewardVault_V3._deleteWhitelistedTokenFromList": [
    "function _deleteWhitelistedTokenFromList(address token) internal {\n        uint256 activeTokens = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < activeTokens; ++i) {\n                if (token == whitelistedTokens[i]) {\n                    whitelistedTokens[i] = whitelistedTokens[activeTokens - 1];\n                    whitelistedTokens.pop();\n                    return;\n                }\n            }\n        }\n    }"
  ],
  "IHoneyFactory.mint": [
    "function mint(address asset, uint256 amount, address receiver, bool expectBasketMode) external returns (uint256);"
  ],
  "IHoneyFactory.redeem": [
    "function redeem(\n        address asset,\n        uint256 honeyAmount,\n        address receiver,\n        bool expectBasketMode\n    )\n        external\n        returns (uint256[] memory);"
  ],
  "IHoneyFactory.liquidate": [
    "function liquidate(\n        address badCollateral,\n        address goodCollateral,\n        uint256 goodAmount\n    )\n        external\n        returns (uint256 badAmount);"
  ],
  "IHoneyFactory.recapitalize": [
    "function recapitalize(address asset, uint256 amount) external;"
  ],
  "HoneyFactoryReader.initialize": [
    "function initialize(address admin, address honeyFactory_) external initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        if (honeyFactory_ == address(0)) ZeroAddress.selector.revertWith();\n        honeyFactory = HoneyFactory(honeyFactory_);\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }"
  ],
  "HoneyFactoryReader._authorizeUpgrade": [
    "function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "HoneyFactoryReader.previewMintCollaterals": [
    "function previewMintCollaterals(address asset, uint256 honey) public view returns (uint256[] memory amounts) {\n        (address[] memory collaterals, uint256 num) = _getCollaterals();\n        amounts = new uint256[](num);\n        uint256[] memory weights = honeyFactory.getWeights();\n        bool basketMode = honeyFactory.isBasketModeEnabled(true);\n        for (uint256 i = 0; i < num; i++) {\n            if (!basketMode && collaterals[i] != asset) {\n                continue;\n            }\n            if (!basketMode && collaterals[i] == asset) {\n                weights[i] = 1e18;\n            }\n            ERC4626 vault = honeyFactory.vaults(collaterals[i]);\n            uint256 mintRate = honeyFactory.mintRates(collaterals[i]);\n            uint256 shares = honey * weights[i] / mintRate;\n            amounts[i] = vault.convertToAssets(shares);\n        }\n    }"
  ],
  "HoneyFactoryReader.previewMintHoney": [
    "function previewMintHoney(\n        address asset,\n        uint256 amount\n    )\n        external\n        view\n        returns (uint256[] memory collaterals, uint256 honey)\n    {\n        bool basketMode = honeyFactory.isBasketModeEnabled(true);\n        collaterals = _getWeightedCollaterals(asset, amount, basketMode);\n        (address[] memory assets, uint256 num) = _getCollaterals();\n        for (uint256 i = 0; i < num; i++) {\n            honey += _previewMint(assets[i], collaterals[i]);\n        }\n    }"
  ],
  "HoneyFactoryReader.previewRedeemCollaterals": [
    "function previewRedeemCollaterals(\n        address asset,\n        uint256 honey\n    )\n        external\n        view\n        returns (uint256[] memory collaterals)\n    {\n        (address[] memory assets, uint256 num) = _getCollaterals();\n        collaterals = new uint256[](num);\n        bool basketMode = honeyFactory.isBasketModeEnabled(false);\n        if (!basketMode) {\n            (uint256 refAssetIndex,) = _getIndexOfAsset(assets, num, asset);\n            collaterals[refAssetIndex] = _previewRedeem(asset, honey);\n            return collaterals;\n        }\n        uint256[] memory weights = honeyFactory.getWeights();\n        for (uint256 i = 0; i < num; i++) {\n            collaterals[i] = _previewRedeem(assets[i], honey * weights[i] / 1e18);\n        }\n    }"
  ],
  "HoneyFactoryReader.previewRedeemHoney": [
    "function previewRedeemHoney(\n        address asset,\n        uint256 amount\n    )\n        external\n        view\n        returns (uint256[] memory collaterals, uint256 honey)\n    {\n        bool basketMode = honeyFactory.isBasketModeEnabled(false);\n        collaterals = _getWeightedCollaterals(asset, amount, basketMode);\n        (address[] memory assets, uint256 num) = _getCollaterals();\n        for (uint256 i = 0; i < num; i++) {\n            honey += _previewHoneyToRedeem(assets[i], collaterals[i]);\n        }\n    }"
  ],
  "HoneyFactoryReader._previewMint": [
    "function _previewMint(address asset, uint256 amount) internal view returns (uint256 honeyAmount) {\n        ERC4626 vault = honeyFactory.vaults(asset);\n        uint256 shares = vault.previewDeposit(amount);\n        honeyAmount = _getHoneyMintedFromShares(asset, shares);\n    }"
  ],
  "HoneyFactoryReader._previewRedeem": [
    "function _previewRedeem(address asset, uint256 honeyAmount) internal view returns (uint256) {\n        ERC4626 vault = honeyFactory.vaults(asset);\n        uint256 shares = _getSharesRedeemedFromHoney(asset, honeyAmount);\n        return vault.previewRedeem(shares);\n    }"
  ],
  "HoneyFactoryReader._getCollaterals": [
    "function _getCollaterals() internal view returns (address[] memory collaterals, uint256 num) {\n        num = honeyFactory.numRegisteredAssets();\n        collaterals = new address[](num);\n        for (uint256 i = 0; i < num; i++) {\n            collaterals[i] = honeyFactory.registeredAssets(i);\n        }\n    }"
  ],
  "HoneyFactoryReader._getHoneyMintedFromShares": [
    "function _getHoneyMintedFromShares(address asset, uint256 shares) internal view returns (uint256 honeyAmount) {\n        uint256 mintRate = honeyFactory.mintRates(asset);\n        honeyAmount = shares * mintRate / 1e18;\n    }"
  ],
  "HoneyFactoryReader._getSharesRedeemedFromHoney": [
    "function _getSharesRedeemedFromHoney(address asset, uint256 honeyAmount) internal view returns (uint256 shares) {\n        uint256 redeemRate = honeyFactory.redeemRates(asset);\n        shares = honeyAmount * redeemRate / 1e18;\n    }"
  ],
  "HoneyFactoryReader._getIndexOfAsset": [
    "function _getIndexOfAsset(\n        address[] memory collaterals,\n        uint256 num,\n        address asset\n    )\n        internal\n        pure\n        returns (uint256 index, bool found)\n    {\n        found = false;\n        for (uint256 i = 0; i < num; i++) {\n            if (collaterals[i] == asset) {\n                found = true;\n                index = i;\n                break;\n            }\n        }\n    }"
  ],
  "HoneyFactoryReader._getWeightedCollaterals": [
    "function _getWeightedCollaterals(\n        address asset,\n        uint256 amount,\n        bool basketMode\n    )\n        internal\n        view\n        returns (uint256[] memory res)\n    {\n        (address[] memory collaterals, uint256 num) = _getCollaterals();\n        res = new uint256[](num);\n        (uint256 refAssetIndex, bool found) = _getIndexOfAsset(collaterals, num, asset);\n        if (!basketMode) {\n            if (found) {\n                res[refAssetIndex] = amount;\n            }\n            return res;\n        }\n        uint256[] memory weights = honeyFactory.getWeights();\n        uint8 decimals = ERC20(asset).decimals();\n        uint256 refAmount = Utils.changeDecimals(amount, decimals, 18);\n        refAmount = refAmount * 1e18 / weights[refAssetIndex];\n        for (uint256 i = 0; i < num; i++) {\n            ERC4626 vault = honeyFactory.vaults(collaterals[i]);\n            res[i] = vault.convertToAssets(refAmount * weights[i] / 1e18);\n        }\n    }"
  ],
  "HoneyFactoryReader._previewHoneyToRedeem": [
    "function _previewHoneyToRedeem(address asset, uint256 exactAmount) internal view returns (uint256) {\n        ERC4626 vault = honeyFactory.vaults(asset);\n        uint256 shares = vault.previewWithdraw(exactAmount);\n        uint256 redeemRate = honeyFactory.redeemRates(asset);\n        return shares * 1e18 / redeemRate;\n    }"
  ],
  "Honey.initialize": [
    "function initialize(address _governance, address _factory) external initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        if (_factory == address(0)) ZeroAddress.selector.revertWith();\n        if (_governance == address(0)) ZeroAddress.selector.revertWith();\n        factory = _factory;\n        _grantRole(DEFAULT_ADMIN_ROLE, _governance);\n    }"
  ],
  "Honey._authorizeUpgrade": [
    "function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "Honey.onlyFactory": [
    "modifier onlyFactory() {\n        if (msg.sender != factory) NotFactory.selector.revertWith();\n        _;\n    }"
  ],
  "Honey.mint": [
    "function mint(address to, uint256 amount) external onlyFactory {\n        _mint(to, amount);\n    }"
  ],
  "Honey.burn": [
    "function burn(address from, uint256 amount) external onlyFactory {\n        _burn(from, amount);\n    }"
  ],
  "Honey.name": [
    "function name() public pure override returns (string memory) {\n        return NAME;\n    }"
  ],
  "Honey.symbol": [
    "function symbol() public pure override returns (string memory) {\n        return SYMBOL;\n    }"
  ],
  "HoneyFactory.initialize": [
    "function initialize(\n        address _governance,\n        address _honey,\n        address _polFeeCollector,\n        address _feeReceiver,\n        address _priceOracle,\n        address _beacon\n    )\n        external\n        initializer\n    {\n        __VaultAdmin_init(_governance, _polFeeCollector, _feeReceiver, _beacon);\n        if (_honey == address(0)) ZeroAddress.selector.revertWith();\n        if (_priceOracle == address(0)) ZeroAddress.selector.revertWith();\n        honey = Honey(_honey);\n        polFeeCollectorFeeRate = ONE_HUNDRED_PERCENT_RATE;\n        priceFeedMaxDelay = 10 seconds;\n        minSharesToRecapitalize = DEFAULT_MIN_SHARES_TO_RECAPITALIZE;\n        priceOracle = IPriceOracle(_priceOracle);\n        globalCap = ONE_HUNDRED_PERCENT_RATE;\n        liquidationEnabled = false;\n    }"
  ],
  "HoneyFactory.setMintRate": [
    "function setMintRate(address asset, uint256 mintRate) external {\n        _checkRole(MANAGER_ROLE);\n        if (mintRate > ONE_HUNDRED_PERCENT_RATE) {\n            OverOneHundredPercentRate.selector.revertWith(mintRate);\n        }\n        if (mintRate < NINETY_EIGHT_PERCENT_RATE) {\n            UnderNinetyEightPercentRate.selector.revertWith(mintRate);\n        }\n        mintRates[asset] = mintRate;\n        emit MintRateSet(asset, mintRate);\n    }"
  ],
  "HoneyFactory.setRedeemRate": [
    "function setRedeemRate(address asset, uint256 redeemRate) external {\n        _checkRole(MANAGER_ROLE);\n        if (redeemRate > ONE_HUNDRED_PERCENT_RATE) {\n            OverOneHundredPercentRate.selector.revertWith(redeemRate);\n        }\n        if (redeemRate < NINETY_EIGHT_PERCENT_RATE) {\n            UnderNinetyEightPercentRate.selector.revertWith(redeemRate);\n        }\n        redeemRates[asset] = redeemRate;\n        emit RedeemRateSet(asset, redeemRate);\n    }"
  ],
  "HoneyFactory.setForcedBasketMode": [
    "function setForcedBasketMode(bool forced) external {\n        _checkRole(MANAGER_ROLE);\n        forcedBasketMode = forced;\n        emit BasketModeForced(forced);\n    }"
  ],
  "HoneyFactory.setMaxFeedDelay": [
    "function setMaxFeedDelay(uint256 maxTolerance) external {\n        _checkRole(MANAGER_ROLE);\n        if (maxTolerance > MAX_PRICE_FEED_DELAY_TOLERANCE) {\n            AmountOutOfRange.selector.revertWith();\n        }\n        priceFeedMaxDelay = maxTolerance;\n        emit MaxFeedDelaySet(maxTolerance);\n    }"
  ],
  "HoneyFactory.setDepegOffsets": [
    "function setDepegOffsets(address asset, uint256 lowerOffset, uint256 upperOffset) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        if (lowerOffset > MAX_PEG_OFFSET || upperOffset > MAX_PEG_OFFSET) {\n            AmountOutOfRange.selector.revertWith();\n        }\n        lowerPegOffsets[asset] = lowerOffset;\n        upperPegOffsets[asset] = upperOffset;\n        emit DepegOffsetsSet(asset, lowerOffset, upperOffset);\n    }"
  ],
  "HoneyFactory.setReferenceCollateral": [
    "function setReferenceCollateral(address asset) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        address old = referenceCollateral;\n        referenceCollateral = asset;\n        emit ReferenceCollateralSet(old, asset);\n    }"
  ],
  "HoneyFactory.setGlobalCap": [
    "function setGlobalCap(uint256 limit) external {\n        _checkRole(MANAGER_ROLE);\n        uint256[] memory weights = _getWeights(true, false);\n        uint256 max = 0;\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (weights[i] > max) {\n                max = weights[i];\n            }\n        }\n        if (limit < max) {\n            CapCanCauseDenialOfService.selector.revertWith();\n        }\n        globalCap = limit;\n        emit GlobalCapSet(limit);\n    }"
  ],
  "HoneyFactory.setRelativeCap": [
    "function setRelativeCap(address asset, uint256 limit) external {\n        _checkRole(MANAGER_ROLE);\n        relativeCap[asset] = limit;\n        emit RelativeCapSet(asset, limit);\n    }"
  ],
  "HoneyFactory.setPOLFeeCollectorFeeRate": [
    "function setPOLFeeCollectorFeeRate(uint256 _polFeeCollectorFeeRate) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (_polFeeCollectorFeeRate > ONE_HUNDRED_PERCENT_RATE) {\n            OverOneHundredPercentRate.selector.revertWith(_polFeeCollectorFeeRate);\n        }\n        polFeeCollectorFeeRate = _polFeeCollectorFeeRate;\n        emit POLFeeCollectorFeeRateSet(_polFeeCollectorFeeRate);\n    }"
  ],
  "HoneyFactory.setLiquidationEnabled": [
    "function setLiquidationEnabled(bool enabled) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        liquidationEnabled = enabled;\n        emit LiquidationStatusSet(enabled);\n    }"
  ],
  "HoneyFactory.setLiquidationRate": [
    "function setLiquidationRate(address asset, uint256 extraRate) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        _checkRegisteredAsset(asset);\n        liquidationRates[asset] = extraRate;\n        emit LiquidationRateSet(asset, extraRate);\n    }"
  ],
  "HoneyFactory.setMinSharesToRecapitalize": [
    "function setMinSharesToRecapitalize(uint256 minSharesAmount) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (minSharesAmount < DEFAULT_MIN_SHARES_TO_RECAPITALIZE) {\n            AmountOutOfRange.selector.revertWith(minSharesAmount);\n        }\n        minSharesToRecapitalize = minSharesAmount;\n        emit MinSharesToRecapitalizeSet(minSharesAmount);\n    }"
  ],
  "HoneyFactory.setRecapitalizeBalanceThreshold": [
    "function setRecapitalizeBalanceThreshold(address asset, uint256 target) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        recapitalizeBalanceThreshold[asset] = target;\n        emit RecapitalizeBalanceThresholdSet(asset, target);\n    }"
  ],
  "HoneyFactory.setPriceOracle": [
    "function setPriceOracle(address priceOracle_) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (priceOracle_ == address(0)) ZeroAddress.selector.revertWith();\n        priceOracle = IPriceOracle(priceOracle_);\n        emit PriceOracleSet(priceOracle_);\n    }"
  ],
  "HoneyFactory.createVault": [
    "function createVault(address asset) external returns (ERC4626 vault) {\n        if (numRegisteredAssets() == 0) {\n            referenceCollateral = asset;\n        }\n        vault = _createVault(asset);\n        relativeCap[asset] = ONE_HUNDRED_PERCENT_RATE;\n        mintRates[asset] = DEFAULT_MINT_REDEEM_RATE;\n        redeemRates[asset] = DEFAULT_MINT_REDEEM_RATE;\n        lowerPegOffsets[asset] = MAX_PEG_OFFSET;\n        upperPegOffsets[asset] = MAX_PEG_OFFSET;\n        if (!isPegged(asset)) {\n            NotPegged.selector.revertWith(asset);\n        }\n        lowerPegOffsets[asset] = DEFAULT_PEG_OFFSET;\n        upperPegOffsets[asset] = DEFAULT_PEG_OFFSET;\n    }"
  ],
  "HoneyFactory.mint": [
    "function mint(\n        address asset,\n        uint256 amount,\n        address receiver,\n        bool expectBasketMode\n    )\n        external\n        whenNotPaused\n        returns (uint256 honeyToMint)\n    {\n        _checkRegisteredAsset(asset);\n        bool basketMode = isBasketModeEnabled(true);\n        if (basketMode != expectBasketMode) {\n            UnexpectedBasketModeStatus.selector.revertWith();\n        }\n        if (!basketMode) {\n            _checkGoodCollateralAsset(asset);\n            if (!isPegged(asset)) {\n                NotPegged.selector.revertWith(asset);\n            }\n            honeyToMint = _mint(asset, amount, receiver, false);\n            if (!_isCappedGlobal(true, asset)) {\n                ExceedGlobalCap.selector.revertWith();\n            }\n        } else {\n            uint256[] memory weights = _getWeights(false, true);\n            uint256 refAssetWeight = weights[_lookupRegistrationIndex(asset)];\n            if (refAssetWeight == 0) {\n                ZeroWeight.selector.revertWith(asset);\n            }\n            uint8 decimals = ERC20(asset).decimals();\n            uint256 refAmount = Utils.changeDecimals(amount, decimals, 18);\n            refAmount = refAmount * 1e18 / refAssetWeight;\n            for (uint256 i = 0; i < registeredAssets.length; i++) {\n                amount = refAmount * weights[i] / 1e18;\n                amount = vaults[registeredAssets[i]].convertToAssets(amount);\n                honeyToMint += _mint(registeredAssets[i], amount, receiver, true);\n            }\n        }\n    }"
  ],
  "HoneyFactory.redeem": [
    "function redeem(\n        address asset,\n        uint256 honeyAmount,\n        address receiver,\n        bool expectBasketMode\n    )\n        external\n        whenNotPaused\n        returns (uint256[] memory redeemed)\n    {\n        _checkRegisteredAsset(asset);\n        bool basketMode = isBasketModeEnabled(false);\n        if (basketMode != expectBasketMode) {\n            UnexpectedBasketModeStatus.selector.revertWith();\n        }\n        if (!basketMode) {\n            redeemed = new uint256[](registeredAssets.length);\n            uint256 index = _lookupRegistrationIndex(asset);\n            redeemed[index] = _redeem(asset, honeyAmount, receiver);\n            if (asset == referenceCollateral) {\n                for (uint256 i = 0; i < registeredAssets.length; i++) {\n                    if (registeredAssets[i] == asset) {\n                        continue;\n                    }\n                    if (!_isCappedRelative(registeredAssets[i])) {\n                        ExceedRelativeCap.selector.revertWith();\n                    }\n                }\n            }\n            if (!_isCappedGlobal(false, asset)) {\n                ExceedGlobalCap.selector.revertWith();\n            }\n            return redeemed;\n        }\n        uint256[] memory weights = _getWeights(false, true);\n        redeemed = new uint256[](registeredAssets.length);\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            uint256 amount = honeyAmount * weights[i] / 1e18;\n            redeemed[i] = _redeem(registeredAssets[i], amount, receiver);\n        }\n    }"
  ],
  "HoneyFactory.liquidate": [
    "function liquidate(\n        address badCollateral,\n        address goodCollateral,\n        uint256 goodAmount\n    )\n        external\n        whenNotPaused\n        returns (uint256 badAmount)\n    {\n        _checkRegisteredAsset(badCollateral);\n        _checkRegisteredAsset(goodCollateral);\n        _checkGoodCollateralAsset(goodCollateral);\n        if (!liquidationEnabled) {\n            LiquidationDisabled.selector.revertWith();\n        }\n        if (!isBadCollateralAsset[badCollateral]) {\n            AssetIsNotBadCollateral.selector.revertWith();\n        }\n        if (badCollateral == referenceCollateral) {\n            LiquidationWithReferenceCollateral.selector.revertWith();\n        }\n        uint256 goodShares = _approveAndDeposit(goodCollateral, goodAmount);\n        uint256 priceBad = _getPrice(badCollateral);\n        uint256 priceGood = _getPrice(goodCollateral);\n        badAmount = (goodShares * priceGood / priceBad) * (1e18 + liquidationRates[badCollateral]) / 1e18;\n        uint256 badShares = _getSharesWithoutFees(badCollateral);\n        if (badAmount > badShares) {\n            uint256 goodSharesAdjusted =\n                (badShares * priceBad / priceGood) * 1e18 / (1e18 + liquidationRates[badCollateral]);\n            _redeemShares(goodCollateral, goodShares - goodSharesAdjusted, msg.sender);\n            badAmount = badShares;\n        }\n        if (!_isCappedRelative(goodCollateral)) {\n            ExceedRelativeCap.selector.revertWith();\n        }\n        if (!_isCappedGlobal(false, badCollateral)) {\n            ExceedGlobalCap.selector.revertWith();\n        }\n        badAmount = _redeemShares(badCollateral, badAmount, msg.sender);\n        if (badAmount == 0) {\n            ZeroAmount.selector.revertWith();\n        }\n        _checkInvariants(badCollateral);\n        _checkInvariants(goodCollateral);\n        emit Liquidated(badCollateral, goodCollateral, goodAmount, msg.sender);\n    }"
  ],
  "HoneyFactory.recapitalize": [
    "function recapitalize(address asset, uint256 amount) external whenNotPaused {\n        _checkRegisteredAsset(asset);\n        _checkGoodCollateralAsset(asset);\n        uint256 targetBalance = recapitalizeBalanceThreshold[asset];\n        uint256 feeAssetBalance = vaults[asset].convertToAssets(collectedAssetFees[asset]);\n        uint256 currentBalance = vaults[asset].totalAssets() - feeAssetBalance;\n        if (currentBalance >= targetBalance) {\n            RecapitalizeNotNeeded.selector.revertWith(asset);\n        }\n        if (!isPegged(asset)) {\n            NotPegged.selector.revertWith(asset);\n        }\n        if (currentBalance + amount > targetBalance) {\n            amount = targetBalance - currentBalance;\n        }\n        uint256 shares = vaults[asset].convertToShares(amount);\n        if (shares < minSharesToRecapitalize) {\n            InsufficientRecapitalizeAmount.selector.revertWith(amount);\n        }\n        _approveAndDeposit(asset, amount);\n        if (!_isCappedRelative(asset)) {\n            ExceedRelativeCap.selector.revertWith();\n        }\n        if (!_isCappedGlobal(true, asset)) {\n            ExceedGlobalCap.selector.revertWith();\n        }\n        _checkInvariants(asset);\n        emit Recapitalized(asset, amount, msg.sender);\n    }"
  ],
  "HoneyFactory.isBasketModeEnabled": [
    "function isBasketModeEnabled(bool isMint) public view returns (bool basketMode) {\n        if (forcedBasketMode) {\n            return true;\n        }\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            bool isPegged_ = isPegged(registeredAssets[i]);\n            if (isMint) {\n                if (isPegged_ && !isBadCollateralAsset[registeredAssets[i]]) {\n                    return false;\n                }\n            } else if (!isPegged_) {\n                bool usedAsCollateral = _getSharesWithoutFees(registeredAssets[i]) > 0;\n                if (!usedAsCollateral) {\n                    continue;\n                }\n                return true;\n            }\n        }\n        return isMint ? true : false;\n    }"
  ],
  "HoneyFactory.getWeights": [
    "function getWeights() external view returns (uint256[] memory w) {\n        w = _getWeights(false, true);\n    }"
  ],
  "HoneyFactory.isPegged": [
    "function isPegged(address asset) public view returns (bool) {\n        if (!priceOracle.priceAvailable(asset)) {\n            return false;\n        }\n        IPriceOracle.Data memory data = priceOracle.getPriceUnsafe(asset);\n        if (data.publishTime < block.timestamp - priceFeedMaxDelay) {\n            return false;\n        }\n        return (1e18 - lowerPegOffsets[asset] <= data.price) && (data.price <= 1e18 + upperPegOffsets[asset]);\n    }"
  ],
  "HoneyFactory._mint": [
    "function _mint(address asset, uint256 amount, address receiver, bool basketMode) internal returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        uint256 shares = _approveAndDeposit(asset, amount);\n        (uint256 honeyToMint, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares) =\n            _getHoneyMintedFromShares(asset, shares);\n        _handleFees(asset, polFeeCollectorFeeShares, feeReceiverFeeShares);\n        if (!basketMode && !_isCappedRelative(asset)) {\n            ExceedRelativeCap.selector.revertWith();\n        }\n        honey.mint(receiver, honeyToMint);\n        _checkInvariants(asset);\n        emit HoneyMinted(msg.sender, receiver, asset, amount, honeyToMint);\n        return honeyToMint;\n    }"
  ],
  "HoneyFactory._redeem": [
    "function _redeem(address asset, uint256 honeyAmount, address receiver) internal returns (uint256 redeemedAssets) {\n        if (honeyAmount == 0) {\n            return 0;\n        }\n        {\n            (uint256 sharesForRedeem, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares) =\n                _getSharesRedeemedFromHoney(asset, honeyAmount);\n            honey.burn(msg.sender, honeyAmount);\n            _handleFees(asset, polFeeCollectorFeeShares, feeReceiverFeeShares);\n            redeemedAssets = _redeemShares(asset, sharesForRedeem, receiver);\n        }\n        _checkInvariants(asset);\n        emit HoneyRedeemed(msg.sender, receiver, asset, redeemedAssets, honeyAmount);\n    }"
  ],
  "HoneyFactory._getHoneyMintedFromShares": [
    "function _getHoneyMintedFromShares(\n        address asset,\n        uint256 shares\n    )\n        internal\n        view\n        returns (uint256 honeyAmount, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares)\n    {\n        uint256 mintRate = mintRates[asset];\n        honeyAmount = shares * mintRate / 1e18;\n        uint256 feeShares = shares - honeyAmount;\n        polFeeCollectorFeeShares = feeShares * polFeeCollectorFeeRate / 1e18;\n        feeReceiverFeeShares = feeShares - polFeeCollectorFeeShares;\n    }"
  ],
  "HoneyFactory._getSharesRedeemedFromHoney": [
    "function _getSharesRedeemedFromHoney(\n        address asset,\n        uint256 honeyAmount\n    )\n        internal\n        view\n        returns (uint256 shares, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares)\n    {\n        uint256 redeemRate = redeemRates[asset];\n        shares = honeyAmount * redeemRate / 1e18;\n        uint256 feeShares = honeyAmount - shares;\n        polFeeCollectorFeeShares = feeShares * polFeeCollectorFeeRate / 1e18;\n        feeReceiverFeeShares = feeShares - polFeeCollectorFeeShares;\n    }"
  ],
  "HoneyFactory._getWeights": [
    "function _getWeights(\n        bool filterBadCollaterals,\n        bool filterPausedCollateral\n    )\n        internal\n        view\n        returns (uint256[] memory weights)\n    {\n        weights = new uint256[](registeredAssets.length);\n        uint256 sum = 0;\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (filterBadCollaterals && isBadCollateralAsset[registeredAssets[i]]) {\n                continue;\n            }\n            if (filterPausedCollateral && vaults[registeredAssets[i]].paused()) {\n                continue;\n            }\n            weights[i] = _getSharesWithoutFees(registeredAssets[i]);\n            sum += weights[i];\n        }\n        if (sum == 0) {\n            return weights;\n        }\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            weights[i] = weights[i] * 1e18 / sum;\n        }\n    }"
  ],
  "HoneyFactory._isCappedRelative": [
    "function _isCappedRelative(address asset) internal view returns (bool) {\n        if (asset == referenceCollateral) {\n            return true;\n        }\n        uint256 balance = _getSharesWithoutFees(asset);\n        uint256 refBalance = _getSharesWithoutFees(referenceCollateral);\n        if (refBalance == 0) {\n            return (balance == 0) ? true : false;\n        }\n        uint256 weight = balance * 1e18 / refBalance;\n        return weight <= relativeCap[asset];\n    }"
  ],
  "HoneyFactory._isCappedGlobal": [
    "function _isCappedGlobal(bool isMint, address collateralAsset) internal view returns (bool) {\n        uint256[] memory weights = _getWeights(true, false);\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (isMint && registeredAssets[i] != collateralAsset) {\n                continue;\n            }\n            if (!isMint && registeredAssets[i] == collateralAsset) {\n                continue;\n            }\n            if (weights[i] > globalCap) {\n                return false;\n            }\n        }\n        return true;\n    }"
  ],
  "HoneyFactory._getPrice": [
    "function _getPrice(address asset) internal view returns (uint256) {\n        IPriceOracle.Data memory data = priceOracle.getPriceNoOlderThan(asset, priceFeedMaxDelay);\n        return data.price;\n    }"
  ],
  "HoneyFactory._getSharesWithoutFees": [
    "function _getSharesWithoutFees(address asset) internal view returns (uint256) {\n        return vaults[asset].balanceOf(address(this)) - collectedAssetFees[asset];\n    }"
  ],
  "HoneyFactory._approveAndDeposit": [
    "function _approveAndDeposit(address asset, uint256 amount) internal returns (uint256 shares) {\n        SafeTransferLib.safeTransferFrom(asset, msg.sender, address(this), amount);\n        SafeTransferLib.safeApprove(asset, address(vaults[asset]), amount);\n        shares = vaults[asset].deposit(amount, address(this));\n    }"
  ],
  "HoneyFactory._redeemShares": [
    "function _redeemShares(address asset, uint256 shares, address receiver) internal returns (uint256) {\n        return vaults[asset].redeem(shares, receiver, address(this));\n    }"
  ],
  "HoneyFactory._handleFees": [
    "function _handleFees(address asset, uint256 polFeeCollectorFeeShares, uint256 feeReceiverFeeShares) internal {\n        if (polFeeCollectorFeeShares > 0) {\n            _redeemShares(asset, polFeeCollectorFeeShares, polFeeCollector);\n        }\n        if (feeReceiverFeeShares > 0) {\n            collectedFees[feeReceiver][asset] += feeReceiverFeeShares;\n            collectedAssetFees[asset] += feeReceiverFeeShares;\n        }\n    }"
  ],
  "HoneyFactory._checkInvariants": [
    "function _checkInvariants(address asset) internal view {\n        ERC4626 vault = vaults[asset];\n        uint256 totalShares = vault.totalSupply();\n        (bool isCustodyVault, address custodyAddress) = CollateralVault(address(vault)).custodyInfo();\n        uint256 totalAssets =\n            isCustodyVault ? ERC20(asset).balanceOf(custodyAddress) : ERC20(asset).balanceOf(address(vault));\n        if (vault.convertToAssets(totalShares) > totalAssets) {\n            InsufficientAssets.selector.revertWith(totalAssets, totalShares);\n        }\n        uint256 vaultShares = vault.balanceOf(address(this));\n        if (vaultShares < collectedAssetFees[asset]) {\n            uint256 vaultAssets = vault.convertToAssets(vaultShares);\n            InsufficientAssets.selector.revertWith(vaultAssets, vaultShares);\n        }\n    }"
  ],
  "CollateralVault.initialize": [
    "function initialize(address asset_, address _factory) external initializer {\n        __CollateralVault_init(asset_, _factory);\n    }"
  ],
  "CollateralVault.__CollateralVault_init": [
    "function __CollateralVault_init(address asset_, address _factory) internal onlyInitializing {\n        __Pausable_init();\n        if (_factory == address(0)) ZeroAddress.selector.revertWith();\n        factory = _factory;\n        ERC20 _asset = ERC20(asset_);\n        _vaultAsset = _asset;\n        _name = string.concat(_asset.name(), \"Vault\");\n        _symbol = string.concat(_asset.symbol(), \"Vault\");\n    }"
  ],
  "CollateralVault.onlyFactory": [
    "modifier onlyFactory() {\n        _checkFactory();\n        _;\n    }"
  ],
  "CollateralVault.pause": [
    "function pause() external onlyFactory {\n        _pause();\n    }"
  ],
  "CollateralVault.unpause": [
    "function unpause() external onlyFactory {\n        _unpause();\n    }"
  ],
  "CollateralVault.deposit": [
    "function deposit(uint256 assets, address receiver) public override onlyFactory whenNotPaused returns (uint256) {\n        return super.deposit(assets, receiver);\n    }"
  ],
  "CollateralVault.mint": [
    "function mint(uint256 shares, address receiver) public override onlyFactory whenNotPaused returns (uint256) {\n        return super.mint(shares, receiver);\n    }"
  ],
  "CollateralVault.setCustodyInfo": [
    "function setCustodyInfo(bool _isCustodyVault, address _custodyAddress) external onlyFactory {\n        if (_isCustodyVault && _custodyAddress == address(0)) ZeroAddress.selector.revertWith();\n        CustodyInfo memory _custodyInfo = custodyInfo;\n        if (_isCustodyVault && _custodyInfo.custodyAddress == address(0)) {\n            SafeTransferLib.safeTransfer(asset(), _custodyAddress, ERC20(asset()).balanceOf(address(this)));\n            custodyInfo = CustodyInfo(_isCustodyVault, _custodyAddress);\n            emit CustodyInfoSet(_isCustodyVault, _custodyAddress);\n            return;\n        }\n        if (!_isCustodyVault && _custodyInfo.custodyAddress == _custodyAddress) {\n            SafeTransferLib.safeTransferFrom(\n                asset(), _custodyAddress, address(this), ERC20(asset()).balanceOf(_custodyAddress)\n            );\n            custodyInfo = CustodyInfo(_isCustodyVault, address(0));\n            emit CustodyInfoSet(_isCustodyVault, address(0));\n            return;\n        }\n        else {\n            InvalidCustodyInfoInput.selector.revertWith();\n        }\n    }"
  ],
  "CollateralVault.withdraw": [
    "function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        public\n        override\n        onlyFactory\n        whenNotPaused\n        returns (uint256)\n    {\n        return super.withdraw(assets, receiver, owner);\n    }"
  ],
  "CollateralVault.redeem": [
    "function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    )\n        public\n        override\n        onlyFactory\n        whenNotPaused\n        returns (uint256)\n    {\n        return super.redeem(shares, receiver, owner);\n    }"
  ],
  "CollateralVault.name": [
    "function name() public view override returns (string memory) {\n        return _name;\n    }"
  ],
  "CollateralVault.symbol": [
    "function symbol() public view override returns (string memory) {\n        return _symbol;\n    }"
  ],
  "CollateralVault.asset": [
    "function asset() public view virtual override returns (address) {\n        return address(_vaultAsset);\n    }"
  ],
  "CollateralVault.convertToAssets": [
    "function convertToAssets(uint256 shares) public view override returns (uint256) {\n        return _convertToAssets(shares);\n    }"
  ],
  "CollateralVault.convertToShares": [
    "function convertToShares(uint256 assets) public view override returns (uint256) {\n        return _convertToShares(assets);\n    }"
  ],
  "CollateralVault.totalAssets": [
    "function totalAssets() public view override returns (uint256) {\n        return _convertToAssets(totalSupply());\n    }"
  ],
  "CollateralVault._initialConvertToShares": [
    "function _initialConvertToShares(uint256 assets) internal view override returns (uint256 shares) {\n        return _convertToShares(assets);\n    }"
  ],
  "CollateralVault._initialConvertToAssets": [
    "function _initialConvertToAssets(uint256 shares) internal view override returns (uint256 assets) {\n        return _convertToAssets(shares);\n    }"
  ],
  "CollateralVault._convertToShares": [
    "function _convertToShares(uint256 assets) private view returns (uint256 shares) {\n        uint8 vaultDecimals = decimals();\n        uint8 assetDecimals = _vaultAsset.decimals();\n        uint256 exponent;\n        if (vaultDecimals >= assetDecimals) {\n            unchecked {\n                exponent = vaultDecimals - assetDecimals;\n            }\n            return assets * (10 ** exponent);\n        }\n        unchecked {\n            exponent = assetDecimals - vaultDecimals;\n        }\n        return assets / (10 ** exponent);\n    }"
  ],
  "CollateralVault._convertToAssets": [
    "function _convertToAssets(uint256 shares) private view returns (uint256 assets) {\n        uint8 vaultDecimals = decimals();\n        uint8 assetDecimals = _vaultAsset.decimals();\n        uint256 exponent;\n        if (vaultDecimals >= assetDecimals) {\n            unchecked {\n                exponent = vaultDecimals - assetDecimals;\n            }\n            return shares / (10 ** exponent);\n        }\n        unchecked {\n            exponent = assetDecimals - vaultDecimals;\n        }\n        return shares * (10 ** exponent);\n    }"
  ],
  "CollateralVault._useVirtualShares": [
    "function _useVirtualShares() internal pure override returns (bool) {\n        return false;\n    }"
  ],
  "CollateralVault._requireNotPaused": [
    "function _requireNotPaused() internal view override {\n        if (paused()) VaultPaused.selector.revertWith(asset());\n    }"
  ],
  "CollateralVault._checkFactory": [
    "function _checkFactory() internal view {\n        if (msg.sender != factory) {\n            NotFactory.selector.revertWith();\n        }\n    }"
  ],
  "CollateralVault._afterDeposit": [
    "function _afterDeposit(uint256 assets, uint256) internal override {\n        if (custodyInfo.isCustodyVault) {\n            SafeTransferLib.safeTransfer(asset(), custodyInfo.custodyAddress, assets);\n        }\n    }"
  ],
  "CollateralVault._beforeWithdraw": [
    "function _beforeWithdraw(uint256 assets, uint256) internal override {\n        if (custodyInfo.isCustodyVault) {\n            SafeTransferLib.safeTransferFrom(asset(), custodyInfo.custodyAddress, address(this), assets);\n        }\n    }"
  ],
  "VaultAdmin.__VaultAdmin_init": [
    "function __VaultAdmin_init(\n        address _governance,\n        address _polFeeCollector,\n        address _feeReceiver,\n        address _beacon\n    )\n        internal\n        onlyInitializing\n    {\n        __AccessControl_init();\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n        __VaultAdmin_init_unchained(_governance, _polFeeCollector, _feeReceiver, _beacon);\n        _setRoleAdmin(PAUSER_ROLE, MANAGER_ROLE);\n    }"
  ],
  "VaultAdmin.__VaultAdmin_init_unchained": [
    "function __VaultAdmin_init_unchained(\n        address _governance,\n        address _polFeeCollector,\n        address _feeReceiver,\n        address _beacon\n    )\n        internal\n        onlyInitializing\n    {\n        if (_governance == address(0)) ZeroAddress.selector.revertWith();\n        if (_polFeeCollector == address(0)) ZeroAddress.selector.revertWith();\n        if (_feeReceiver == address(0)) ZeroAddress.selector.revertWith();\n        if (_beacon == address(0)) ZeroAddress.selector.revertWith();\n        beacon = _beacon;\n        _grantRole(DEFAULT_ADMIN_ROLE, _governance);\n        feeReceiver = _feeReceiver;\n        polFeeCollector = _polFeeCollector;\n        emit FeeReceiverSet(_feeReceiver);\n        emit POLFeeCollectorSet(_polFeeCollector);\n    }"
  ],
  "VaultAdmin._checkRegisteredAsset": [
    "function _checkRegisteredAsset(address asset) internal view {\n        if (address(vaults[asset]) == address(0)) {\n            AssetNotRegistered.selector.revertWith(asset);\n        }\n    }"
  ],
  "VaultAdmin._checkGoodCollateralAsset": [
    "function _checkGoodCollateralAsset(address asset) internal view {\n        if (isBadCollateralAsset[asset]) {\n            AssetIsBadCollateral.selector.revertWith(asset);\n        }\n    }"
  ],
  "VaultAdmin._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal virtual override {\n        newImplementation;\n        _checkRole(DEFAULT_ADMIN_ROLE);\n    }"
  ],
  "VaultAdmin.pause": [
    "function pause() external {\n        _checkRole(PAUSER_ROLE);\n        _pause();\n    }"
  ],
  "VaultAdmin.unpause": [
    "function unpause() external {\n        _checkRole(MANAGER_ROLE);\n        _unpause();\n    }"
  ],
  "VaultAdmin.pauseVault": [
    "function pauseVault(address asset) external {\n        _checkRole(PAUSER_ROLE);\n        _checkRegisteredAsset(asset);\n        CollateralVault(address(vaults[asset])).pause();\n    }"
  ],
  "VaultAdmin.unpauseVault": [
    "function unpauseVault(address asset) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        CollateralVault(address(vaults[asset])).unpause();\n    }"
  ],
  "VaultAdmin.setCustodyInfo": [
    "function setCustodyInfo(address asset, bool isCustodyVault, address custodyAddress) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        _checkRegisteredAsset(asset);\n        vaults[asset].setCustodyInfo(isCustodyVault, custodyAddress);\n    }"
  ],
  "VaultAdmin._createVault": [
    "function _createVault(address asset) internal returns (CollateralVault) {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (address(vaults[asset]) != address(0)) {\n            VaultAlreadyRegistered.selector.revertWith(asset);\n        }\n        registeredAssets.push(asset);\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            mstore(0, shr(96, shl(96, asset)))\n            salt := keccak256(0, 0x20)\n        }\n        CollateralVault vault = CollateralVault(LibClone.deployDeterministicERC1967BeaconProxy(beacon, salt));\n        vault.initialize(asset, address(this));\n        vaults[asset] = vault;\n        emit VaultCreated(address(vault), address(asset));\n        return vault;\n    }"
  ],
  "VaultAdmin.setFeeReceiver": [
    "function setFeeReceiver(address _feeReceiver) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (_feeReceiver == address(0)) ZeroAddress.selector.revertWith();\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverSet(_feeReceiver);\n    }"
  ],
  "VaultAdmin.setPOLFeeCollector": [
    "function setPOLFeeCollector(address _polFeeCollector) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (_polFeeCollector == address(0)) ZeroAddress.selector.revertWith();\n        polFeeCollector = _polFeeCollector;\n        emit POLFeeCollectorSet(_polFeeCollector);\n    }"
  ],
  "VaultAdmin.setCollateralAssetStatus": [
    "function setCollateralAssetStatus(address asset, bool _isBadCollateral) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        isBadCollateralAsset[asset] = _isBadCollateral;\n        emit CollateralAssetStatusSet(asset, _isBadCollateral);\n    }"
  ],
  "VaultAdmin.withdrawAllFees": [
    "function withdrawAllFees(address receiver) external {\n        uint256 numAssets = numRegisteredAssets();\n        for (uint256 i; i < numAssets;) {\n            address asset = registeredAssets[i];\n            _withdrawCollectedFee(asset, receiver);\n            unchecked {\n                ++i;\n            }\n        }\n    }"
  ],
  "VaultAdmin.withdrawFee": [
    "function withdrawFee(address asset, address receiver) external returns (uint256 assets) {\n        _checkRegisteredAsset(asset);\n        assets = _withdrawCollectedFee(asset, receiver);\n    }"
  ],
  "VaultAdmin._withdrawCollectedFee": [
    "function _withdrawCollectedFee(address asset, address receiver) internal returns (uint256 assets) {\n        uint256 shares = collectedFees[receiver][asset];\n        if (vaults[asset].convertToAssets(shares) == 0) {\n            return 0;\n        }\n        collectedFees[receiver][asset] = 0;\n        collectedAssetFees[asset] -= shares;\n        assets = vaults[asset].redeem(shares, receiver, address(this));\n        emit CollectedFeeWithdrawn(asset, receiver, shares, assets);\n    }"
  ],
  "VaultAdmin.numRegisteredAssets": [
    "function numRegisteredAssets() public view returns (uint256) {\n        return registeredAssets.length;\n    }"
  ],
  "VaultAdmin._lookupRegistrationIndex": [
    "function _lookupRegistrationIndex(address asset) internal view returns (uint256 index) {\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (registeredAssets[i] == asset) {\n                return i;\n            }\n        }\n    }"
  ],
  "BeraChef_V0.initialize": [
    "function initialize(\n        address _distributor,\n        address _factory,\n        address _governance,\n        address _beaconDepositContract,\n        uint8 _maxNumWeightsPerRewardAllocation\n    )\n        external\n        initializer\n    {\n        __Ownable_init(_governance);\n        __UUPSUpgradeable_init();\n        distributor = _distributor;\n        factory = _factory;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        if (_maxNumWeightsPerRewardAllocation == 0) {\n            MaxNumWeightsPerRewardAllocationIsZero.selector.revertWith();\n        }\n        emit MaxNumWeightsPerRewardAllocationSet(_maxNumWeightsPerRewardAllocation);\n        maxNumWeightsPerRewardAllocation = _maxNumWeightsPerRewardAllocation;\n    }"
  ],
  "BeraChef_V0._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }"
  ],
  "BeraChef_V0.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) {\n            NotDistributor.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "BeraChef_V0.onlyOperator": [
    "modifier onlyOperator(bytes calldata valPubkey) {\n        if (msg.sender != beaconDepositContract.getOperator(valPubkey)) {\n            NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "BeraChef_V0.setMaxNumWeightsPerRewardAllocation": [
    "function setMaxNumWeightsPerRewardAllocation(uint8 _maxNumWeightsPerRewardAllocation) external onlyOwner {\n        if (_maxNumWeightsPerRewardAllocation == 0) {\n            MaxNumWeightsPerRewardAllocationIsZero.selector.revertWith();\n        }\n        if (_maxNumWeightsPerRewardAllocation < defaultRewardAllocation.weights.length) {\n            InvalidateDefaultRewardAllocation.selector.revertWith();\n        }\n        maxNumWeightsPerRewardAllocation = _maxNumWeightsPerRewardAllocation;\n        emit MaxNumWeightsPerRewardAllocationSet(_maxNumWeightsPerRewardAllocation);\n    }"
  ],
  "BeraChef_V0.setRewardAllocationBlockDelay": [
    "function setRewardAllocationBlockDelay(uint64 _rewardAllocationBlockDelay) external onlyOwner {\n        if (_rewardAllocationBlockDelay > MAX_REWARD_ALLOCATION_BLOCK_DELAY) {\n            RewardAllocationBlockDelayTooLarge.selector.revertWith();\n        }\n        rewardAllocationBlockDelay = _rewardAllocationBlockDelay;\n        emit RewardAllocationBlockDelaySet(_rewardAllocationBlockDelay);\n    }"
  ],
  "BeraChef_V0.setVaultWhitelistedStatus": [
    "function setVaultWhitelistedStatus(\n        address receiver,\n        bool isWhitelisted,\n        string memory metadata\n    )\n        external\n        onlyOwner\n    {\n        address stakeToken = address(RewardVault_V0(receiver).stakeToken());\n        address factoryVault = IRewardVaultFactory_V0(factory).getVault(stakeToken);\n        if (receiver != factoryVault) {\n            NotFactoryVault.selector.revertWith();\n        }\n        isWhitelistedVault[receiver] = isWhitelisted;\n        if (!isWhitelisted) {\n            if (!_checkIfStillValid(defaultRewardAllocation.weights)) {\n                InvalidRewardAllocationWeights.selector.revertWith();\n            }\n        }\n        emit VaultWhitelistedStatusUpdated(receiver, isWhitelisted, metadata);\n    }"
  ],
  "BeraChef_V0.updateWhitelistedVaultMetadata": [
    "function updateWhitelistedVaultMetadata(address vault, string memory metadata) external onlyOwner {\n        if (!isWhitelistedVault[vault]) {\n            NotWhitelistedVault.selector.revertWith();\n        }\n        emit WhitelistedVaultMetadataUpdated(vault, metadata);\n    }"
  ],
  "BeraChef_V0.setDefaultRewardAllocation": [
    "function setDefaultRewardAllocation(RewardAllocation calldata ra) external onlyOwner {\n        _validateWeights(ra.weights);\n        emit SetDefaultRewardAllocation(ra);\n        defaultRewardAllocation = ra;\n    }"
  ],
  "BeraChef_V0.queueNewRewardAllocation": [
    "function queueNewRewardAllocation(\n        bytes calldata valPubkey,\n        uint64 startBlock,\n        Weight[] calldata weights\n    )\n        external\n        onlyOperator(valPubkey)\n    {\n        if (startBlock <= block.number + rewardAllocationBlockDelay) {\n            InvalidStartBlock.selector.revertWith();\n        }\n        RewardAllocation storage qra = queuedRewardAllocations[valPubkey];\n        if (qra.startBlock > 0) {\n            RewardAllocationAlreadyQueued.selector.revertWith();\n        }\n        _validateWeights(weights);\n        qra.startBlock = startBlock;\n        Weight[] storage storageWeights = qra.weights;\n        for (uint256 i; i < weights.length;) {\n            storageWeights.push(weights[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        emit QueueRewardAllocation(valPubkey, startBlock, weights);\n    }"
  ],
  "BeraChef_V0.activateReadyQueuedRewardAllocation": [
    "function activateReadyQueuedRewardAllocation(bytes calldata valPubkey) external onlyDistributor {\n        if (!isQueuedRewardAllocationReady(valPubkey, block.number)) return;\n        RewardAllocation storage qra = queuedRewardAllocations[valPubkey];\n        uint64 startBlock = qra.startBlock;\n        activeRewardAllocations[valPubkey] = qra;\n        emit ActivateRewardAllocation(valPubkey, startBlock, qra.weights);\n        delete queuedRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef_V0.getActiveRewardAllocation": [
    "function getActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        RewardAllocation memory ara = activeRewardAllocations[valPubkey];\n        if (ara.startBlock > 0 && _checkIfStillValid(ara.weights)) {\n            return ara;\n        }\n        return defaultRewardAllocation;\n    }"
  ],
  "BeraChef_V0.getQueuedRewardAllocation": [
    "function getQueuedRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        return queuedRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef_V0.getSetActiveRewardAllocation": [
    "function getSetActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        return activeRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef_V0.getDefaultRewardAllocation": [
    "function getDefaultRewardAllocation() external view returns (RewardAllocation memory) {\n        return defaultRewardAllocation;\n    }"
  ],
  "BeraChef_V0.isQueuedRewardAllocationReady": [
    "function isQueuedRewardAllocationReady(bytes calldata valPubkey, uint256 blockNumber) public view returns (bool) {\n        uint64 startBlock = queuedRewardAllocations[valPubkey].startBlock;\n        return startBlock != 0 && startBlock <= blockNumber;\n    }"
  ],
  "BeraChef_V0.isReady": [
    "function isReady() external view returns (bool) {\n        return defaultRewardAllocation.weights.length > 0;\n    }"
  ],
  "BeraChef_V0._validateWeights": [
    "function _validateWeights(Weight[] calldata weights) internal view {\n        if (weights.length > maxNumWeightsPerRewardAllocation) {\n            TooManyWeights.selector.revertWith();\n        }\n        uint96 totalWeight;\n        for (uint256 i; i < weights.length;) {\n            Weight calldata weight = weights[i];\n            if (weight.percentageNumerator == 0) {\n                ZeroPercentageWeight.selector.revertWith();\n            }\n            if (!isWhitelistedVault[weight.receiver]) {\n                NotWhitelistedVault.selector.revertWith();\n            }\n            totalWeight += weight.percentageNumerator;\n            unchecked {\n                ++i;\n            }\n        }\n        if (totalWeight != ONE_HUNDRED_PERCENT) {\n            InvalidRewardAllocationWeights.selector.revertWith();\n        }\n    }"
  ],
  "BeraChef_V0._checkIfStillValid": [
    "function _checkIfStillValid(Weight[] memory weights) internal view returns (bool) {\n        uint256 length = weights.length;\n        if (length > maxNumWeightsPerRewardAllocation) {\n            return false;\n        }\n        for (uint256 i; i < length;) {\n            if (!isWhitelistedVault[weights[i].receiver]) {\n                return false;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }"
  ],
  "HoneyFactory_V0.initialize": [
    "function initialize(\n        address _governance,\n        address _honey,\n        address _polFeeCollector,\n        address _feeReceiver,\n        address _priceOracle\n    )\n        external\n        initializer\n    {\n        __VaultAdmin_init(_governance, _polFeeCollector, _feeReceiver);\n        if (_honey == address(0)) ZeroAddress.selector.revertWith();\n        if (_priceOracle == address(0)) ZeroAddress.selector.revertWith();\n        honey = Honey(_honey);\n        polFeeCollectorFeeRate = ONE_HUNDRED_PERCENT_RATE;\n        priceFeedMaxDelay = 10 seconds;\n        minSharesToRecapitalize = DEFAULT_MIN_SHARES_TO_RECAPITALIZE;\n        priceOracle = IPriceOracle(_priceOracle);\n        globalCap = ONE_HUNDRED_PERCENT_RATE;\n        liquidationEnabled = false;\n    }"
  ],
  "HoneyFactory_V0.setMintRate": [
    "function setMintRate(address asset, uint256 mintRate) external {\n        _checkRole(MANAGER_ROLE);\n        if (mintRate > ONE_HUNDRED_PERCENT_RATE) {\n            OverOneHundredPercentRate.selector.revertWith(mintRate);\n        }\n        if (mintRate < NINETY_EIGHT_PERCENT_RATE) {\n            UnderNinetyEightPercentRate.selector.revertWith(mintRate);\n        }\n        mintRates[asset] = mintRate;\n        emit MintRateSet(asset, mintRate);\n    }"
  ],
  "HoneyFactory_V0.setRedeemRate": [
    "function setRedeemRate(address asset, uint256 redeemRate) external {\n        _checkRole(MANAGER_ROLE);\n        if (redeemRate > ONE_HUNDRED_PERCENT_RATE) {\n            OverOneHundredPercentRate.selector.revertWith(redeemRate);\n        }\n        if (redeemRate < NINETY_EIGHT_PERCENT_RATE) {\n            UnderNinetyEightPercentRate.selector.revertWith(redeemRate);\n        }\n        redeemRates[asset] = redeemRate;\n        emit RedeemRateSet(asset, redeemRate);\n    }"
  ],
  "HoneyFactory_V0.setForcedBasketMode": [
    "function setForcedBasketMode(bool forced) external {\n        _checkRole(MANAGER_ROLE);\n        forcedBasketMode = forced;\n        emit BasketModeForced(forced);\n    }"
  ],
  "HoneyFactory_V0.setMaxFeedDelay": [
    "function setMaxFeedDelay(uint256 maxTolerance) external {\n        _checkRole(MANAGER_ROLE);\n        if (maxTolerance > MAX_PRICE_FEED_DELAY_TOLERANCE) {\n            AmountOutOfRange.selector.revertWith();\n        }\n        priceFeedMaxDelay = maxTolerance;\n        emit MaxFeedDelaySet(maxTolerance);\n    }"
  ],
  "HoneyFactory_V0.setDepegOffsets": [
    "function setDepegOffsets(address asset, uint256 lowerOffset, uint256 upperOffset) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        if (lowerOffset > MAX_PEG_OFFSET || upperOffset > MAX_PEG_OFFSET) {\n            AmountOutOfRange.selector.revertWith();\n        }\n        lowerPegOffsets[asset] = lowerOffset;\n        upperPegOffsets[asset] = upperOffset;\n        emit DepegOffsetsSet(asset, lowerOffset, upperOffset);\n    }"
  ],
  "HoneyFactory_V0.setReferenceCollateral": [
    "function setReferenceCollateral(address asset) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        address old = referenceCollateral;\n        referenceCollateral = asset;\n        emit ReferenceCollateralSet(old, asset);\n    }"
  ],
  "HoneyFactory_V0.setGlobalCap": [
    "function setGlobalCap(uint256 limit) external {\n        _checkRole(MANAGER_ROLE);\n        uint256[] memory weights = _getWeights(true, false);\n        uint256 max = 0;\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (weights[i] > max) {\n                max = weights[i];\n            }\n        }\n        if (limit < max) {\n            CapCanCauseDenialOfService.selector.revertWith();\n        }\n        globalCap = limit;\n        emit GlobalCapSet(limit);\n    }"
  ],
  "HoneyFactory_V0.setRelativeCap": [
    "function setRelativeCap(address asset, uint256 limit) external {\n        _checkRole(MANAGER_ROLE);\n        relativeCap[asset] = limit;\n        emit RelativeCapSet(asset, limit);\n    }"
  ],
  "HoneyFactory_V0.setPOLFeeCollectorFeeRate": [
    "function setPOLFeeCollectorFeeRate(uint256 _polFeeCollectorFeeRate) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (_polFeeCollectorFeeRate > ONE_HUNDRED_PERCENT_RATE) {\n            OverOneHundredPercentRate.selector.revertWith(_polFeeCollectorFeeRate);\n        }\n        polFeeCollectorFeeRate = _polFeeCollectorFeeRate;\n        emit POLFeeCollectorFeeRateSet(_polFeeCollectorFeeRate);\n    }"
  ],
  "HoneyFactory_V0.setLiquidationEnabled": [
    "function setLiquidationEnabled(bool enabled) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        liquidationEnabled = enabled;\n        emit LiquidationStatusSet(enabled);\n    }"
  ],
  "HoneyFactory_V0.setLiquidationRate": [
    "function setLiquidationRate(address asset, uint256 extraRate) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        _checkRegisteredAsset(asset);\n        liquidationRates[asset] = extraRate;\n        emit LiquidationRateSet(asset, extraRate);\n    }"
  ],
  "HoneyFactory_V0.setMinSharesToRecapitalize": [
    "function setMinSharesToRecapitalize(uint256 minSharesAmount) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (minSharesAmount < DEFAULT_MIN_SHARES_TO_RECAPITALIZE) {\n            AmountOutOfRange.selector.revertWith(minSharesAmount);\n        }\n        minSharesToRecapitalize = minSharesAmount;\n        emit MinSharesToRecapitalizeSet(minSharesAmount);\n    }"
  ],
  "HoneyFactory_V0.setRecapitalizeBalanceThreshold": [
    "function setRecapitalizeBalanceThreshold(address asset, uint256 target) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        recapitalizeBalanceThreshold[asset] = target;\n        emit RecapitalizeBalanceThresholdSet(asset, target);\n    }"
  ],
  "HoneyFactory_V0.setPriceOracle": [
    "function setPriceOracle(address priceOracle_) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (priceOracle_ == address(0)) ZeroAddress.selector.revertWith();\n        priceOracle = IPriceOracle(priceOracle_);\n        emit PriceOracleSet(priceOracle_);\n    }"
  ],
  "HoneyFactory_V0.createVault": [
    "function createVault(address asset) external returns (ERC4626 vault) {\n        if (numRegisteredAssets() == 0) {\n            referenceCollateral = asset;\n        }\n        vault = _createVault(asset);\n        relativeCap[asset] = ONE_HUNDRED_PERCENT_RATE;\n        mintRates[asset] = DEFAULT_MINT_REDEEM_RATE;\n        redeemRates[asset] = DEFAULT_MINT_REDEEM_RATE;\n        lowerPegOffsets[asset] = MAX_PEG_OFFSET;\n        upperPegOffsets[asset] = MAX_PEG_OFFSET;\n        if (!isPegged(asset)) {\n            NotPegged.selector.revertWith(asset);\n        }\n        lowerPegOffsets[asset] = DEFAULT_PEG_OFFSET;\n        upperPegOffsets[asset] = DEFAULT_PEG_OFFSET;\n    }"
  ],
  "HoneyFactory_V0.mint": [
    "function mint(\n        address asset,\n        uint256 amount,\n        address receiver,\n        bool expectBasketMode\n    )\n        external\n        whenNotPaused\n        returns (uint256 honeyToMint)\n    {\n        _checkRegisteredAsset(asset);\n        bool basketMode = isBasketModeEnabled(true);\n        if (basketMode != expectBasketMode) {\n            UnexpectedBasketModeStatus.selector.revertWith();\n        }\n        if (!basketMode) {\n            _checkGoodCollateralAsset(asset);\n            if (!isPegged(asset)) {\n                NotPegged.selector.revertWith(asset);\n            }\n            honeyToMint = _mint(asset, amount, receiver, false);\n            if (!_isCappedGlobal(true, asset)) {\n                ExceedGlobalCap.selector.revertWith();\n            }\n        } else {\n            uint256[] memory weights = _getWeights(false, true);\n            uint256 refAssetWeight = weights[_lookupRegistrationIndex(asset)];\n            if (refAssetWeight == 0) {\n                ZeroWeight.selector.revertWith(asset);\n            }\n            uint8 decimals = ERC20(asset).decimals();\n            uint256 refAmount = Utils.changeDecimals(amount, decimals, 18);\n            refAmount = refAmount * 1e18 / refAssetWeight;\n            for (uint256 i = 0; i < registeredAssets.length; i++) {\n                amount = refAmount * weights[i] / 1e18;\n                amount = vaults[registeredAssets[i]].convertToAssets(amount);\n                honeyToMint += _mint(registeredAssets[i], amount, receiver, true);\n            }\n        }\n    }"
  ],
  "HoneyFactory_V0.redeem": [
    "function redeem(\n        address asset,\n        uint256 honeyAmount,\n        address receiver,\n        bool expectBasketMode\n    )\n        external\n        whenNotPaused\n        returns (uint256[] memory redeemed)\n    {\n        _checkRegisteredAsset(asset);\n        bool basketMode = isBasketModeEnabled(false);\n        if (basketMode != expectBasketMode) {\n            UnexpectedBasketModeStatus.selector.revertWith();\n        }\n        if (!basketMode) {\n            redeemed = new uint256[](registeredAssets.length);\n            uint256 index = _lookupRegistrationIndex(asset);\n            redeemed[index] = _redeem(asset, honeyAmount, receiver);\n            if (asset == referenceCollateral) {\n                for (uint256 i = 0; i < registeredAssets.length; i++) {\n                    if (registeredAssets[i] == asset) {\n                        continue;\n                    }\n                    if (!_isCappedRelative(registeredAssets[i])) {\n                        ExceedRelativeCap.selector.revertWith();\n                    }\n                }\n            }\n            if (!_isCappedGlobal(false, asset)) {\n                ExceedGlobalCap.selector.revertWith();\n            }\n            return redeemed;\n        }\n        uint256[] memory weights = _getWeights(false, true);\n        redeemed = new uint256[](registeredAssets.length);\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            uint256 amount = honeyAmount * weights[i] / 1e18;\n            redeemed[i] = _redeem(registeredAssets[i], amount, receiver);\n        }\n    }"
  ],
  "HoneyFactory_V0.liquidate": [
    "function liquidate(\n        address badCollateral,\n        address goodCollateral,\n        uint256 goodAmount\n    )\n        external\n        whenNotPaused\n        returns (uint256 badAmount)\n    {\n        _checkRegisteredAsset(badCollateral);\n        _checkRegisteredAsset(goodCollateral);\n        _checkGoodCollateralAsset(goodCollateral);\n        if (!liquidationEnabled) {\n            LiquidationDisabled.selector.revertWith();\n        }\n        if (!isBadCollateralAsset[badCollateral]) {\n            AssetIsNotBadCollateral.selector.revertWith();\n        }\n        if (badCollateral == referenceCollateral) {\n            LiquidationWithReferenceCollateral.selector.revertWith();\n        }\n        uint256 goodShares = _approveAndDeposit(goodCollateral, goodAmount);\n        uint256 priceBad = _getPrice(badCollateral);\n        uint256 priceGood = _getPrice(goodCollateral);\n        badAmount = (goodShares * priceGood / priceBad) * (1e18 + liquidationRates[badCollateral]) / 1e18;\n        uint256 badShares = _getSharesWithoutFees(badCollateral);\n        if (badAmount > badShares) {\n            uint256 goodSharesAdjusted =\n                (badShares * priceBad / priceGood) * 1e18 / (1e18 + liquidationRates[badCollateral]);\n            _redeemShares(goodCollateral, goodShares - goodSharesAdjusted, msg.sender);\n            badAmount = badShares;\n        }\n        if (!_isCappedRelative(goodCollateral)) {\n            ExceedRelativeCap.selector.revertWith();\n        }\n        if (!_isCappedGlobal(false, badCollateral)) {\n            ExceedGlobalCap.selector.revertWith();\n        }\n        badAmount = _redeemShares(badCollateral, badAmount, msg.sender);\n        if (badAmount == 0) {\n            ZeroAmount.selector.revertWith();\n        }\n        _checkInvariants(badCollateral);\n        _checkInvariants(goodCollateral);\n        emit Liquidated(badCollateral, goodCollateral, goodAmount, msg.sender);\n    }"
  ],
  "HoneyFactory_V0.recapitalize": [
    "function recapitalize(address asset, uint256 amount) external whenNotPaused {\n        _checkRegisteredAsset(asset);\n        _checkGoodCollateralAsset(asset);\n        uint256 targetBalance = recapitalizeBalanceThreshold[asset];\n        uint256 feeAssetBalance = vaults[asset].convertToAssets(collectedAssetFees[asset]);\n        uint256 currentBalance = vaults[asset].totalAssets() - feeAssetBalance;\n        if (currentBalance >= targetBalance) {\n            RecapitalizeNotNeeded.selector.revertWith(asset);\n        }\n        if (!isPegged(asset)) {\n            NotPegged.selector.revertWith(asset);\n        }\n        if (currentBalance + amount > targetBalance) {\n            amount = targetBalance - currentBalance;\n        }\n        uint256 shares = vaults[asset].convertToShares(amount);\n        if (shares < minSharesToRecapitalize) {\n            InsufficientRecapitalizeAmount.selector.revertWith(amount);\n        }\n        _approveAndDeposit(asset, amount);\n        if (!_isCappedRelative(asset)) {\n            ExceedRelativeCap.selector.revertWith();\n        }\n        if (!_isCappedGlobal(true, asset)) {\n            ExceedGlobalCap.selector.revertWith();\n        }\n        _checkInvariants(asset);\n        emit Recapitalized(asset, amount, msg.sender);\n    }"
  ],
  "HoneyFactory_V0.isBasketModeEnabled": [
    "function isBasketModeEnabled(bool isMint) public view returns (bool basketMode) {\n        if (forcedBasketMode) {\n            return true;\n        }\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            bool isPegged_ = isPegged(registeredAssets[i]);\n            if (isMint) {\n                if (isPegged_ && !isBadCollateralAsset[registeredAssets[i]]) {\n                    return false;\n                }\n            } else if (!isPegged_) {\n                bool usedAsCollateral = _getSharesWithoutFees(registeredAssets[i]) > 0;\n                if (!usedAsCollateral) {\n                    continue;\n                }\n                return true;\n            }\n        }\n        return isMint ? true : false;\n    }"
  ],
  "HoneyFactory_V0.getWeights": [
    "function getWeights() external view returns (uint256[] memory w) {\n        w = _getWeights(false, true);\n    }"
  ],
  "HoneyFactory_V0.isPegged": [
    "function isPegged(address asset) public view returns (bool) {\n        if (!priceOracle.priceAvailable(asset)) {\n            return false;\n        }\n        IPriceOracle.Data memory data = priceOracle.getPriceUnsafe(asset);\n        if (data.publishTime < block.timestamp - priceFeedMaxDelay) {\n            return false;\n        }\n        return (1e18 - lowerPegOffsets[asset] <= data.price) && (data.price <= 1e18 + upperPegOffsets[asset]);\n    }"
  ],
  "HoneyFactory_V0._mint": [
    "function _mint(address asset, uint256 amount, address receiver, bool basketMode) internal returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        uint256 shares = _approveAndDeposit(asset, amount);\n        (uint256 honeyToMint, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares) =\n            _getHoneyMintedFromShares(asset, shares);\n        _handleFees(asset, polFeeCollectorFeeShares, feeReceiverFeeShares);\n        if (!basketMode && !_isCappedRelative(asset)) {\n            ExceedRelativeCap.selector.revertWith();\n        }\n        honey.mint(receiver, honeyToMint);\n        _checkInvariants(asset);\n        emit HoneyMinted(msg.sender, receiver, asset, amount, honeyToMint);\n        return honeyToMint;\n    }"
  ],
  "HoneyFactory_V0._redeem": [
    "function _redeem(address asset, uint256 honeyAmount, address receiver) internal returns (uint256 redeemedAssets) {\n        if (honeyAmount == 0) {\n            return 0;\n        }\n        {\n            (uint256 sharesForRedeem, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares) =\n                _getSharesRedeemedFromHoney(asset, honeyAmount);\n            honey.burn(msg.sender, honeyAmount);\n            _handleFees(asset, polFeeCollectorFeeShares, feeReceiverFeeShares);\n            redeemedAssets = _redeemShares(asset, sharesForRedeem, receiver);\n        }\n        _checkInvariants(asset);\n        emit HoneyRedeemed(msg.sender, receiver, asset, redeemedAssets, honeyAmount);\n    }"
  ],
  "HoneyFactory_V0._getHoneyMintedFromShares": [
    "function _getHoneyMintedFromShares(\n        address asset,\n        uint256 shares\n    )\n        internal\n        view\n        returns (uint256 honeyAmount, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares)\n    {\n        uint256 mintRate = mintRates[asset];\n        honeyAmount = shares * mintRate / 1e18;\n        uint256 feeShares = shares - honeyAmount;\n        polFeeCollectorFeeShares = feeShares * polFeeCollectorFeeRate / 1e18;\n        feeReceiverFeeShares = feeShares - polFeeCollectorFeeShares;\n    }"
  ],
  "HoneyFactory_V0._getSharesRedeemedFromHoney": [
    "function _getSharesRedeemedFromHoney(\n        address asset,\n        uint256 honeyAmount\n    )\n        internal\n        view\n        returns (uint256 shares, uint256 feeReceiverFeeShares, uint256 polFeeCollectorFeeShares)\n    {\n        uint256 redeemRate = redeemRates[asset];\n        shares = honeyAmount * redeemRate / 1e18;\n        uint256 feeShares = honeyAmount - shares;\n        polFeeCollectorFeeShares = feeShares * polFeeCollectorFeeRate / 1e18;\n        feeReceiverFeeShares = feeShares - polFeeCollectorFeeShares;\n    }"
  ],
  "HoneyFactory_V0._getWeights": [
    "function _getWeights(\n        bool filterBadCollaterals,\n        bool filterPausedCollateral\n    )\n        internal\n        view\n        returns (uint256[] memory weights)\n    {\n        weights = new uint256[](registeredAssets.length);\n        uint256 sum = 0;\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (filterBadCollaterals && isBadCollateralAsset[registeredAssets[i]]) {\n                continue;\n            }\n            if (filterPausedCollateral && vaults[registeredAssets[i]].paused()) {\n                continue;\n            }\n            weights[i] = _getSharesWithoutFees(registeredAssets[i]);\n            sum += weights[i];\n        }\n        if (sum == 0) {\n            return weights;\n        }\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            weights[i] = weights[i] * 1e18 / sum;\n        }\n    }"
  ],
  "HoneyFactory_V0._isCappedRelative": [
    "function _isCappedRelative(address asset) internal view returns (bool) {\n        if (asset == referenceCollateral) {\n            return true;\n        }\n        uint256 balance = _getSharesWithoutFees(asset);\n        uint256 refBalance = _getSharesWithoutFees(referenceCollateral);\n        if (refBalance == 0) {\n            return (balance == 0) ? true : false;\n        }\n        uint256 weight = balance * 1e18 / refBalance;\n        return weight <= relativeCap[asset];\n    }"
  ],
  "HoneyFactory_V0._isCappedGlobal": [
    "function _isCappedGlobal(bool isMint, address collateralAsset) internal view returns (bool) {\n        uint256[] memory weights = _getWeights(true, false);\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (isMint && registeredAssets[i] != collateralAsset) {\n                continue;\n            }\n            if (!isMint && registeredAssets[i] == collateralAsset) {\n                continue;\n            }\n            if (weights[i] > globalCap) {\n                return false;\n            }\n        }\n        return true;\n    }"
  ],
  "HoneyFactory_V0._getPrice": [
    "function _getPrice(address asset) internal view returns (uint256) {\n        IPriceOracle.Data memory data = priceOracle.getPriceNoOlderThan(asset, priceFeedMaxDelay);\n        return data.price;\n    }"
  ],
  "HoneyFactory_V0._getSharesWithoutFees": [
    "function _getSharesWithoutFees(address asset) internal view returns (uint256) {\n        return vaults[asset].balanceOf(address(this)) - collectedAssetFees[asset];\n    }"
  ],
  "HoneyFactory_V0._approveAndDeposit": [
    "function _approveAndDeposit(address asset, uint256 amount) internal returns (uint256 shares) {\n        SafeTransferLib.safeTransferFrom(asset, msg.sender, address(this), amount);\n        SafeTransferLib.safeApprove(asset, address(vaults[asset]), amount);\n        shares = vaults[asset].deposit(amount, address(this));\n    }"
  ],
  "HoneyFactory_V0._redeemShares": [
    "function _redeemShares(address asset, uint256 shares, address receiver) internal returns (uint256) {\n        return vaults[asset].redeem(shares, receiver, address(this));\n    }"
  ],
  "HoneyFactory_V0._handleFees": [
    "function _handleFees(address asset, uint256 polFeeCollectorFeeShares, uint256 feeReceiverFeeShares) internal {\n        if (polFeeCollectorFeeShares > 0) {\n            _redeemShares(asset, polFeeCollectorFeeShares, polFeeCollector);\n        }\n        if (feeReceiverFeeShares > 0) {\n            collectedFees[feeReceiver][asset] += feeReceiverFeeShares;\n            collectedAssetFees[asset] += feeReceiverFeeShares;\n        }\n    }"
  ],
  "HoneyFactory_V0._checkInvariants": [
    "function _checkInvariants(address asset) internal view {\n        ERC4626 vault = vaults[asset];\n        uint256 totalShares = vault.totalSupply();\n        uint256 totalAssets = ERC20(asset).balanceOf(address(vault));\n        if (vault.convertToAssets(totalShares) > totalAssets) {\n            InsufficientAssets.selector.revertWith(totalAssets, totalShares);\n        }\n        uint256 vaultShares = vault.balanceOf(address(this));\n        if (vaultShares < collectedAssetFees[asset]) {\n            uint256 vaultAssets = vault.convertToAssets(vaultShares);\n            InsufficientAssets.selector.revertWith(vaultAssets, vaultShares);\n        }\n    }"
  ],
  "RewardVault_V0.initialize": [
    "function initialize(\n        address _beaconDepositContract,\n        address _bgt,\n        address _distributor,\n        address _stakingToken\n    )\n        external\n        initializer\n    {\n        __FactoryOwnable_init(msg.sender);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __StakingRewards_init(_stakingToken, _bgt, 7 days);\n        maxIncentiveTokensCount = 2;\n        distributor = _distributor;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        emit DistributorSet(_distributor);\n        emit MaxIncentiveTokensCountUpdated(2);\n    }"
  ],
  "RewardVault_V0.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) NotDistributor.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V0.onlyOperatorOrUser": [
    "modifier onlyOperatorOrUser(address account) {\n        if (msg.sender != account) {\n            if (msg.sender != _operators[account]) NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "RewardVault_V0.checkSelfStakedBalance": [
    "modifier checkSelfStakedBalance(address account, uint256 amount) {\n        _checkSelfStakedBalance(account, amount);\n        _;\n    }"
  ],
  "RewardVault_V0.onlyWhitelistedToken": [
    "modifier onlyWhitelistedToken(address token) {\n        if (incentives[token].minIncentiveRate == 0) TokenNotWhitelisted.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V0.setDistributor": [
    "function setDistributor(address _rewardDistribution) external onlyFactoryOwner {\n        if (_rewardDistribution == address(0)) ZeroAddress.selector.revertWith();\n        distributor = _rewardDistribution;\n        emit DistributorSet(_rewardDistribution);\n    }"
  ],
  "RewardVault_V0.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external onlyDistributor {\n        _notifyRewardAmount(reward);\n        _processIncentives(pubkey, reward);\n    }"
  ],
  "RewardVault_V0.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyFactoryOwner {\n        if (tokenAddress == address(stakeToken)) CannotRecoverStakingToken.selector.revertWith();\n        if (incentives[tokenAddress].minIncentiveRate != 0) CannotRecoverIncentiveToken.selector.revertWith();\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }"
  ],
  "RewardVault_V0.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external onlyFactoryOwner {\n        _setRewardsDuration(_rewardsDuration);\n    }"
  ],
  "RewardVault_V0.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(\n        address token,\n        uint256 minIncentiveRate,\n        address manager\n    )\n        external\n        onlyFactoryOwner\n    {\n        if (minIncentiveRate == 0) MinIncentiveRateIsZero.selector.revertWith();\n        if (minIncentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        if (token == address(0) || manager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        if (whitelistedTokens.length == maxIncentiveTokensCount || incentive.minIncentiveRate != 0) {\n            TokenAlreadyWhitelistedOrLimitReached.selector.revertWith();\n        }\n        whitelistedTokens.push(token);\n        incentive.incentiveRate = minIncentiveRate;\n        incentive.minIncentiveRate = minIncentiveRate;\n        incentive.manager = manager;\n        emit IncentiveTokenWhitelisted(token, minIncentiveRate, manager);\n    }"
  ],
  "RewardVault_V0.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external onlyFactoryVaultManager onlyWhitelistedToken(token) {\n        delete incentives[token];\n        _deleteWhitelistedTokenFromList(token);\n        emit IncentiveTokenRemoved(token);\n    }"
  ],
  "RewardVault_V0.updateIncentiveManager": [
    "function updateIncentiveManager(\n        address token,\n        address newManager\n    )\n        external\n        onlyFactoryOwner\n        onlyWhitelistedToken(token)\n    {\n        if (newManager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        address currentManager = incentive.manager;\n        incentive.manager = newManager;\n        emit IncentiveManagerChanged(token, newManager, currentManager);\n    }"
  ],
  "RewardVault_V0.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external onlyFactoryOwner {\n        if (_maxIncentiveTokensCount < whitelistedTokens.length) {\n            InvalidMaxIncentiveTokensCount.selector.revertWith();\n        }\n        maxIncentiveTokensCount = _maxIncentiveTokensCount;\n        emit MaxIncentiveTokensCountUpdated(_maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault_V0.pause": [
    "function pause() external onlyFactoryVaultPauser {\n        _pause();\n    }"
  ],
  "RewardVault_V0.unpause": [
    "function unpause() external onlyFactoryVaultManager {\n        _unpause();\n    }"
  ],
  "RewardVault_V0.operator": [
    "function operator(address account) external view returns (address) {\n        return _operators[account];\n    }"
  ],
  "RewardVault_V0.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256) {\n        return whitelistedTokens.length;\n    }"
  ],
  "RewardVault_V0.getWhitelistedTokens": [
    "function getWhitelistedTokens() public view returns (address[] memory) {\n        return whitelistedTokens;\n    }"
  ],
  "RewardVault_V0.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256) {\n        return _delegateStake[account].delegateTotalStaked;\n    }"
  ],
  "RewardVault_V0.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256) {\n        return _delegateStake[account].stakedByDelegate[delegate];\n    }"
  ],
  "RewardVault_V0.stake": [
    "function stake(uint256 amount) external nonReentrant whenNotPaused {\n        _stake(msg.sender, amount);\n    }"
  ],
  "RewardVault_V0.delegateStake": [
    "function delegateStake(address account, uint256 amount) external nonReentrant whenNotPaused {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        _stake(account, amount);\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            info.delegateTotalStaked += amount;\n            info.stakedByDelegate[msg.sender] += amount;\n        }\n        emit DelegateStaked(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V0.withdraw": [
    "function withdraw(uint256 amount) external nonReentrant checkSelfStakedBalance(msg.sender, amount) {\n        _withdraw(msg.sender, amount);\n    }"
  ],
  "RewardVault_V0.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external nonReentrant {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            uint256 stakedByDelegate = info.stakedByDelegate[msg.sender];\n            if (stakedByDelegate < amount) InsufficientDelegateStake.selector.revertWith();\n            info.stakedByDelegate[msg.sender] = stakedByDelegate - amount;\n            info.delegateTotalStaked -= amount;\n        }\n        _withdraw(account, amount);\n        emit DelegateWithdrawn(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V0.getReward": [
    "function getReward(\n        address account,\n        address recipient\n    )\n        external\n        nonReentrant\n        onlyOperatorOrUser(account)\n        returns (uint256)\n    {\n        return _getReward(account, recipient);\n    }"
  ],
  "RewardVault_V0.exit": [
    "function exit(address recipient) external nonReentrant {\n        uint256 amount = _accountInfo[msg.sender].balance - _delegateStake[msg.sender].delegateTotalStaked;\n        _withdraw(msg.sender, amount);\n        _getReward(msg.sender, recipient);\n    }"
  ],
  "RewardVault_V0.setOperator": [
    "function setOperator(address _operator) external {\n        _operators[msg.sender] = _operator;\n        emit OperatorSet(msg.sender, _operator);\n    }"
  ],
  "RewardVault_V0.addIncentive": [
    "function addIncentive(\n        address token,\n        uint256 amount,\n        uint256 incentiveRate\n    )\n        external\n        nonReentrant\n        onlyWhitelistedToken(token)\n    {\n        if (incentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        incentive.amountRemaining = amountRemainingBefore + amount;\n        if (amountRemainingBefore == 0 && incentiveRate >= minIncentiveRate) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else if (incentiveRate > incentiveRateStored) {\n            uint256 rateDelta;\n            unchecked {\n                rateDelta = incentiveRate - incentiveRateStored;\n            }\n            if (amount >= FixedPointMathLib.mulDiv(amountRemainingBefore, rateDelta, incentiveRateStored)) {\n                incentive.incentiveRate = incentiveRate;\n            }\n        }\n        emit IncentiveAdded(token, msg.sender, amount, incentive.incentiveRate);\n    }"
  ],
  "RewardVault_V0._checkSelfStakedBalance": [
    "function _checkSelfStakedBalance(address account, uint256 amount) internal view {\n        unchecked {\n            uint256 selfStaked = _accountInfo[account].balance - _delegateStake[account].delegateTotalStaked;\n            if (selfStaked < amount) InsufficientSelfStake.selector.revertWith();\n        }\n    }"
  ],
  "RewardVault_V0._safeTransferRewardToken": [
    "function _safeTransferRewardToken(address to, uint256 amount) internal override {\n        rewardToken.safeTransferFrom(distributor, to, amount);\n    }"
  ],
  "RewardVault_V0._checkRewardSolvency": [
    "function _checkRewardSolvency() internal view override {\n        uint256 allowance = rewardToken.allowance(distributor, address(this));\n        if (undistributedRewards / PRECISION > allowance) InsolventReward.selector.revertWith();\n    }"
  ],
  "RewardVault_V0._processIncentives": [
    "function _processIncentives(bytes calldata pubkey, uint256 bgtEmitted) internal {\n        address _operator = beaconDepositContract.getOperator(pubkey);\n        uint256 whitelistedTokensCount = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < whitelistedTokensCount; ++i) {\n                address token = whitelistedTokens[i];\n                Incentive storage incentive = incentives[token];\n                uint256 amount = FixedPointMathLib.mulDiv(bgtEmitted, incentive.incentiveRate, PRECISION);\n                uint256 amountRemaining = incentive.amountRemaining;\n                amount = FixedPointMathLib.min(amount, amountRemaining);\n                if (amount > 0) {\n                    bool success = token.trySafeTransfer(_operator, amount);\n                    if (success) {\n                        incentive.amountRemaining = amountRemaining - amount;\n                        emit IncentivesProcessed(pubkey, token, bgtEmitted, amount);\n                    } else {\n                        emit IncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                    }\n                }\n            }\n        }\n    }"
  ],
  "RewardVault_V0._deleteWhitelistedTokenFromList": [
    "function _deleteWhitelistedTokenFromList(address token) internal {\n        uint256 activeTokens = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < activeTokens; ++i) {\n                if (token == whitelistedTokens[i]) {\n                    whitelistedTokens[i] = whitelistedTokens[activeTokens - 1];\n                    whitelistedTokens.pop();\n                    return;\n                }\n            }\n        }\n    }"
  ],
  "RewardVaultFactory_V0.initialize": [
    "function initialize(\n        address _bgt,\n        address _distributor,\n        address _beaconDepositContract,\n        address _governance,\n        address _vaultImpl\n    )\n        external\n        initializer\n    {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, _governance);\n        _setRoleAdmin(VAULT_PAUSER_ROLE, VAULT_MANAGER_ROLE);\n        bgt = _bgt;\n        distributor = _distributor;\n        beaconDepositContract = _beaconDepositContract;\n        beacon = address(new UpgradeableBeacon(_governance, _vaultImpl));\n    }"
  ],
  "RewardVaultFactory_V0._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "RewardVaultFactory_V0.createRewardVault": [
    "function createRewardVault(address stakingToken) external returns (address) {\n        address cachedAddress = getVault[stakingToken];\n        if (cachedAddress != address(0)) return cachedAddress;\n        if (stakingToken.code.length == 0) NotAContract.selector.revertWith();\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            mstore(0, stakingToken)\n            salt := keccak256(0, 0x20)\n        }\n        address vault = LibClone.deployDeterministicERC1967BeaconProxy(beacon, salt);\n        getVault[stakingToken] = vault;\n        allVaults.push(vault);\n        emit VaultCreated(stakingToken, vault);\n        RewardVault_V0(vault).initialize(beaconDepositContract, bgt, distributor, stakingToken);\n        return vault;\n    }"
  ],
  "RewardVaultFactory_V0.predictRewardVaultAddress": [
    "function predictRewardVaultAddress(address stakingToken) external view returns (address) {\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            mstore(0, stakingToken)\n            salt := keccak256(0, 0x20)\n        }\n        return LibClone.predictDeterministicAddressERC1967BeaconProxy(beacon, salt, address(this));\n    }"
  ],
  "RewardVaultFactory_V0.allVaultsLength": [
    "function allVaultsLength() external view returns (uint256) {\n        return allVaults.length;\n    }"
  ],
  "VaultAdmin_V0.__VaultAdmin_init": [
    "function __VaultAdmin_init(\n        address _governance,\n        address _polFeeCollector,\n        address _feeReceiver\n    )\n        internal\n        onlyInitializing\n    {\n        __AccessControl_init();\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n        __VaultAdmin_init_unchained(_governance, _polFeeCollector, _feeReceiver);\n        _setRoleAdmin(PAUSER_ROLE, MANAGER_ROLE);\n    }"
  ],
  "VaultAdmin_V0.__VaultAdmin_init_unchained": [
    "function __VaultAdmin_init_unchained(\n        address _governance,\n        address _polFeeCollector,\n        address _feeReceiver\n    )\n        internal\n        onlyInitializing\n    {\n        if (_governance == address(0)) ZeroAddress.selector.revertWith();\n        if (_polFeeCollector == address(0)) ZeroAddress.selector.revertWith();\n        if (_feeReceiver == address(0)) ZeroAddress.selector.revertWith();\n        beacon = address(new UpgradeableBeacon(_governance, address(new CollateralVault_V0())));\n        _grantRole(DEFAULT_ADMIN_ROLE, _governance);\n        feeReceiver = _feeReceiver;\n        polFeeCollector = _polFeeCollector;\n        emit FeeReceiverSet(_feeReceiver);\n        emit POLFeeCollectorSet(_polFeeCollector);\n    }"
  ],
  "VaultAdmin_V0._checkRegisteredAsset": [
    "function _checkRegisteredAsset(address asset) internal view {\n        if (address(vaults[asset]) == address(0)) {\n            AssetNotRegistered.selector.revertWith(asset);\n        }\n    }"
  ],
  "VaultAdmin_V0._checkGoodCollateralAsset": [
    "function _checkGoodCollateralAsset(address asset) internal view {\n        if (isBadCollateralAsset[asset]) {\n            AssetIsBadCollateral.selector.revertWith(asset);\n        }\n    }"
  ],
  "VaultAdmin_V0._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal virtual override {\n        newImplementation;\n        _checkRole(DEFAULT_ADMIN_ROLE);\n    }"
  ],
  "VaultAdmin_V0.pause": [
    "function pause() external {\n        _checkRole(PAUSER_ROLE);\n        _pause();\n    }"
  ],
  "VaultAdmin_V0.unpause": [
    "function unpause() external {\n        _checkRole(MANAGER_ROLE);\n        _unpause();\n    }"
  ],
  "VaultAdmin_V0.pauseVault": [
    "function pauseVault(address asset) external {\n        _checkRole(PAUSER_ROLE);\n        _checkRegisteredAsset(asset);\n        CollateralVault_V0(address(vaults[asset])).pause();\n    }"
  ],
  "VaultAdmin_V0.unpauseVault": [
    "function unpauseVault(address asset) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        CollateralVault_V0(address(vaults[asset])).unpause();\n    }"
  ],
  "VaultAdmin_V0._createVault": [
    "function _createVault(address asset) internal returns (CollateralVault_V0) {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (address(vaults[asset]) != address(0)) {\n            VaultAlreadyRegistered.selector.revertWith(asset);\n        }\n        registeredAssets.push(asset);\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            mstore(0, shr(96, shl(96, asset)))\n            salt := keccak256(0, 0x20)\n        }\n        CollateralVault_V0 vault = CollateralVault_V0(LibClone.deployDeterministicERC1967BeaconProxy(beacon, salt));\n        vault.initialize(asset, address(this));\n        vaults[asset] = vault;\n        emit VaultCreated(address(vault), address(asset));\n        return vault;\n    }"
  ],
  "VaultAdmin_V0.setFeeReceiver": [
    "function setFeeReceiver(address _feeReceiver) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (_feeReceiver == address(0)) ZeroAddress.selector.revertWith();\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverSet(_feeReceiver);\n    }"
  ],
  "VaultAdmin_V0.setPOLFeeCollector": [
    "function setPOLFeeCollector(address _polFeeCollector) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (_polFeeCollector == address(0)) ZeroAddress.selector.revertWith();\n        polFeeCollector = _polFeeCollector;\n        emit POLFeeCollectorSet(_polFeeCollector);\n    }"
  ],
  "VaultAdmin_V0.setCollateralAssetStatus": [
    "function setCollateralAssetStatus(address asset, bool _isBadCollateral) external {\n        _checkRole(MANAGER_ROLE);\n        _checkRegisteredAsset(asset);\n        isBadCollateralAsset[asset] = _isBadCollateral;\n        emit CollateralAssetStatusSet(asset, _isBadCollateral);\n    }"
  ],
  "VaultAdmin_V0.withdrawAllFees": [
    "function withdrawAllFees(address receiver) external {\n        uint256 numAssets = numRegisteredAssets();\n        for (uint256 i; i < numAssets;) {\n            address asset = registeredAssets[i];\n            _withdrawCollectedFee(asset, receiver);\n            unchecked {\n                ++i;\n            }\n        }\n    }"
  ],
  "VaultAdmin_V0.withdrawFee": [
    "function withdrawFee(address asset, address receiver) external returns (uint256 assets) {\n        _checkRegisteredAsset(asset);\n        assets = _withdrawCollectedFee(asset, receiver);\n    }"
  ],
  "VaultAdmin_V0._withdrawCollectedFee": [
    "function _withdrawCollectedFee(address asset, address receiver) internal returns (uint256 assets) {\n        uint256 shares = collectedFees[receiver][asset];\n        if (vaults[asset].convertToAssets(shares) == 0) {\n            return 0;\n        }\n        collectedFees[receiver][asset] = 0;\n        collectedAssetFees[asset] -= shares;\n        assets = vaults[asset].redeem(shares, receiver, address(this));\n        emit CollectedFeeWithdrawn(asset, receiver, shares, assets);\n    }"
  ],
  "VaultAdmin_V0.numRegisteredAssets": [
    "function numRegisteredAssets() public view returns (uint256) {\n        return registeredAssets.length;\n    }"
  ],
  "VaultAdmin_V0._lookupRegistrationIndex": [
    "function _lookupRegistrationIndex(address asset) internal view returns (uint256 index) {\n        for (uint256 i = 0; i < registeredAssets.length; i++) {\n            if (registeredAssets[i] == asset) {\n                return i;\n            }\n        }\n    }"
  ],
  "CollateralVault_V0.initialize": [
    "function initialize(address asset_, address _factory) external initializer {\n        __Pausable_init();\n        __CollateralVault_init(asset_, _factory);\n    }"
  ],
  "CollateralVault_V0.__CollateralVault_init": [
    "function __CollateralVault_init(address asset_, address _factory) internal onlyInitializing {\n        if (_factory == address(0)) ZeroAddress.selector.revertWith();\n        factory = _factory;\n        ERC20 _asset = ERC20(asset_);\n        _vaultAsset = _asset;\n        _name = string.concat(_asset.name(), \"Vault\");\n        _symbol = string.concat(_asset.symbol(), \"Vault\");\n    }"
  ],
  "CollateralVault_V0.onlyFactory": [
    "modifier onlyFactory() {\n        _checkFactory();\n        _;\n    }"
  ],
  "CollateralVault_V0.pause": [
    "function pause() external onlyFactory {\n        _pause();\n    }"
  ],
  "CollateralVault_V0.unpause": [
    "function unpause() external onlyFactory {\n        _unpause();\n    }"
  ],
  "CollateralVault_V0.deposit": [
    "function deposit(uint256 assets, address receiver) public override onlyFactory whenNotPaused returns (uint256) {\n        return super.deposit(assets, receiver);\n    }"
  ],
  "CollateralVault_V0.mint": [
    "function mint(uint256 shares, address receiver) public override onlyFactory whenNotPaused returns (uint256) {\n        return super.mint(shares, receiver);\n    }"
  ],
  "CollateralVault_V0.withdraw": [
    "function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        public\n        override\n        onlyFactory\n        whenNotPaused\n        returns (uint256)\n    {\n        return super.withdraw(assets, receiver, owner);\n    }"
  ],
  "CollateralVault_V0.redeem": [
    "function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    )\n        public\n        override\n        onlyFactory\n        whenNotPaused\n        returns (uint256)\n    {\n        return super.redeem(shares, receiver, owner);\n    }"
  ],
  "CollateralVault_V0.name": [
    "function name() public view override returns (string memory) {\n        return _name;\n    }"
  ],
  "CollateralVault_V0.symbol": [
    "function symbol() public view override returns (string memory) {\n        return _symbol;\n    }"
  ],
  "CollateralVault_V0.asset": [
    "function asset() public view virtual override returns (address) {\n        return address(_vaultAsset);\n    }"
  ],
  "CollateralVault_V0.convertToAssets": [
    "function convertToAssets(uint256 shares) public view override returns (uint256) {\n        return _convertToAssets(shares);\n    }"
  ],
  "CollateralVault_V0.convertToShares": [
    "function convertToShares(uint256 assets) public view override returns (uint256) {\n        return _convertToShares(assets);\n    }"
  ],
  "CollateralVault_V0.totalAssets": [
    "function totalAssets() public view override returns (uint256) {\n        return _convertToAssets(totalSupply());\n    }"
  ],
  "CollateralVault_V0._initialConvertToShares": [
    "function _initialConvertToShares(uint256 assets) internal view override returns (uint256 shares) {\n        return _convertToShares(assets);\n    }"
  ],
  "CollateralVault_V0._initialConvertToAssets": [
    "function _initialConvertToAssets(uint256 shares) internal view override returns (uint256 assets) {\n        return _convertToAssets(shares);\n    }"
  ],
  "CollateralVault_V0._convertToShares": [
    "function _convertToShares(uint256 assets) private view returns (uint256 shares) {\n        uint8 vaultDecimals = decimals();\n        uint8 assetDecimals = _vaultAsset.decimals();\n        uint256 exponent;\n        if (vaultDecimals >= assetDecimals) {\n            unchecked {\n                exponent = vaultDecimals - assetDecimals;\n            }\n            return assets * (10 ** exponent);\n        }\n        unchecked {\n            exponent = assetDecimals - vaultDecimals;\n        }\n        return assets / (10 ** exponent);\n    }"
  ],
  "CollateralVault_V0._convertToAssets": [
    "function _convertToAssets(uint256 shares) private view returns (uint256 assets) {\n        uint8 vaultDecimals = decimals();\n        uint8 assetDecimals = _vaultAsset.decimals();\n        uint256 exponent;\n        if (vaultDecimals >= assetDecimals) {\n            unchecked {\n                exponent = vaultDecimals - assetDecimals;\n            }\n            return shares / (10 ** exponent);\n        }\n        unchecked {\n            exponent = assetDecimals - vaultDecimals;\n        }\n        return shares * (10 ** exponent);\n    }"
  ],
  "CollateralVault_V0._useVirtualShares": [
    "function _useVirtualShares() internal pure override returns (bool) {\n        return false;\n    }"
  ],
  "CollateralVault_V0._requireNotPaused": [
    "function _requireNotPaused() internal view override {\n        if (paused()) VaultPaused.selector.revertWith(asset());\n    }"
  ],
  "CollateralVault_V0._checkFactory": [
    "function _checkFactory() internal view {\n        if (msg.sender != factory) {\n            NotFactory.selector.revertWith();\n        }\n    }"
  ],
  "IRewardVaultFactory_V0.createRewardVault": [
    "function createRewardVault(address stakingToken) external returns (address);"
  ],
  "IRewardVaultFactory_V0.VAULT_MANAGER_ROLE": [
    "function VAULT_MANAGER_ROLE() external view returns (bytes32);"
  ],
  "IRewardVaultFactory_V0.VAULT_PAUSER_ROLE": [
    "function VAULT_PAUSER_ROLE() external view returns (bytes32);"
  ],
  "IRewardVaultFactory_V0.getVault": [
    "function getVault(address stakingToken) external view returns (address);"
  ],
  "IRewardVaultFactory_V0.allVaultsLength": [
    "function allVaultsLength() external view returns (uint256);"
  ],
  "IRewardVaultFactory_V0.predictRewardVaultAddress": [
    "function predictRewardVaultAddress(address stakingToken) external view returns (address);"
  ],
  "IBeraChef_V0.getActiveRewardAllocation": [
    "function getActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V0.getQueuedRewardAllocation": [
    "function getQueuedRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V0.getSetActiveRewardAllocation": [
    "function getSetActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V0.getDefaultRewardAllocation": [
    "function getDefaultRewardAllocation() external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V0.isQueuedRewardAllocationReady": [
    "function isQueuedRewardAllocationReady(\n        bytes calldata valPubkey,\n        uint256 blockNumber\n    )\n        external\n        view\n        returns (bool);"
  ],
  "IBeraChef_V0.isReady": [
    "function isReady() external view returns (bool);"
  ],
  "IBeraChef_V0.setMaxNumWeightsPerRewardAllocation": [
    "function setMaxNumWeightsPerRewardAllocation(uint8 _maxNumWeightsPerRewardAllocation) external;"
  ],
  "IBeraChef_V0.setRewardAllocationBlockDelay": [
    "function setRewardAllocationBlockDelay(uint64 _rewardAllocationBlockDelay) external;"
  ],
  "IBeraChef_V0.setVaultWhitelistedStatus": [
    "function setVaultWhitelistedStatus(address receiver, bool isWhitelisted, string memory metadata) external;"
  ],
  "IBeraChef_V0.updateWhitelistedVaultMetadata": [
    "function updateWhitelistedVaultMetadata(address receiver, string memory metadata) external;"
  ],
  "IBeraChef_V0.setDefaultRewardAllocation": [
    "function setDefaultRewardAllocation(RewardAllocation calldata rewardAllocation) external;"
  ],
  "IBeraChef_V0.queueNewRewardAllocation": [
    "function queueNewRewardAllocation(\n        bytes calldata valPubkey,\n        uint64 startBlock,\n        Weight[] calldata weights\n    )\n        external;"
  ],
  "IBeraChef_V0.activateReadyQueuedRewardAllocation": [
    "function activateReadyQueuedRewardAllocation(bytes calldata valPubkey) external;"
  ],
  "IRewardVault_V0.distributor": [
    "function distributor() external view returns (address);"
  ],
  "IRewardVault_V0.operator": [
    "function operator(address account) external view returns (address);"
  ],
  "IRewardVault_V0.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256);"
  ],
  "IRewardVault_V0.getWhitelistedTokens": [
    "function getWhitelistedTokens() external view returns (address[] memory);"
  ],
  "IRewardVault_V0.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256);"
  ],
  "IRewardVault_V0.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256);"
  ],
  "IRewardVault_V0.initialize": [
    "function initialize(address _berachef, address _bgt, address _distributor, address _stakingToken) external;"
  ],
  "IRewardVault_V0.setDistributor": [
    "function setDistributor(address _rewardDistribution) external;"
  ],
  "IRewardVault_V0.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external;"
  ],
  "IRewardVault_V0.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external;"
  ],
  "IRewardVault_V0.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external;"
  ],
  "IRewardVault_V0.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(address token, uint256 minIncentiveRate, address manager) external;"
  ],
  "IRewardVault_V0.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external;"
  ],
  "IRewardVault_V0.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external;"
  ],
  "IRewardVault_V0.pause": [
    "function pause() external;"
  ],
  "IRewardVault_V0.unpause": [
    "function unpause() external;"
  ],
  "IRewardVault_V0.exit": [
    "function exit(address recipient) external;"
  ],
  "IRewardVault_V0.getReward": [
    "function getReward(address account, address recipient) external returns (uint256);"
  ],
  "IRewardVault_V0.stake": [
    "function stake(uint256 amount) external;"
  ],
  "IRewardVault_V0.delegateStake": [
    "function delegateStake(address account, uint256 amount) external;"
  ],
  "IRewardVault_V0.withdraw": [
    "function withdraw(uint256 amount) external;"
  ],
  "IRewardVault_V0.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external;"
  ],
  "IRewardVault_V0.setOperator": [
    "function setOperator(address _operator) external;"
  ],
  "IRewardVault_V0.updateIncentiveManager": [
    "function updateIncentiveManager(address token, address newManager) external;"
  ],
  "IRewardVault_V0.addIncentive": [
    "function addIncentive(address token, uint256 amount, uint256 incentiveRate) external;"
  ],
  "Create2Deployer.deployWithCreate2": [
    "function deployWithCreate2(uint256 salt, bytes memory initCode) internal returns (address addr) {\n        assembly (\"memory-safe\") {\n            let length := mload(initCode)\n            mstore(initCode, salt)\n            if iszero(call(gas(), _CREATE2_FACTORY, 0, initCode, add(length, 0x20), 0, 0x14)) {\n                mstore(0, 0x30116425) \n                revert(0x1c, 0x04)\n            }\n            addr := shr(96, mload(0))\n            mstore(initCode, length)\n        }\n    }"
  ],
  "Create2Deployer.getCreate2Address": [
    "function getCreate2Address(uint256 salt, bytes memory initCode) internal pure returns (address) {\n        return getCreate2Address(salt, keccak256(initCode));\n    }",
    "function getCreate2Address(uint256 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return bytes32(salt).computeAddress(initCodeHash, _CREATE2_FACTORY);\n    }"
  ],
  "Create2Deployer.deployProxyWithCreate2": [
    "function deployProxyWithCreate2(address implementation, uint256 salt) internal returns (address) {\n        return deployWithCreate2(salt, initCodeERC1967(implementation));\n    }"
  ],
  "Create2Deployer.getCreate2ProxyAddress": [
    "function getCreate2ProxyAddress(address implementation, uint256 salt) internal pure returns (address) {\n        return getCreate2Address(salt, initCodeERC1967(implementation));\n    }"
  ],
  "Create2Deployer.initCodeERC1967": [
    "function initCodeERC1967(address implementation) internal pure returns (bytes memory) {\n        return abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(implementation, bytes(\"\")));\n    }"
  ],
  "IStakingRewards.balanceOf": [
    "function balanceOf(address account) external view returns (uint256);"
  ],
  "IStakingRewards.rewards": [
    "function rewards(address account) external view returns (uint256);"
  ],
  "IStakingRewards.userRewardPerTokenPaid": [
    "function userRewardPerTokenPaid(address account) external view returns (uint256);"
  ],
  "IStakingRewards.earned": [
    "function earned(address account) external view returns (uint256);"
  ],
  "IStakingRewards.getRewardForDuration": [
    "function getRewardForDuration() external view returns (uint256);"
  ],
  "IStakingRewards.lastTimeRewardApplicable": [
    "function lastTimeRewardApplicable() external view returns (uint256);"
  ],
  "IStakingRewards.rewardPerToken": [
    "function rewardPerToken() external view returns (uint256);"
  ],
  "IStakingRewards.totalSupply": [
    "function totalSupply() external view returns (uint256);"
  ],
  "IStakingRewards.periodFinish": [
    "function periodFinish() external view returns (uint256);"
  ],
  "IStakingRewards.rewardRate": [
    "function rewardRate() external view returns (uint256);"
  ],
  "IStakingRewards.rewardsDuration": [
    "function rewardsDuration() external view returns (uint256);"
  ],
  "IStakingRewards.lastUpdateTime": [
    "function lastUpdateTime() external view returns (uint256);"
  ],
  "IStakingRewards.undistributedRewards": [
    "function undistributedRewards() external view returns (uint256);"
  ],
  "IStakingRewards.rewardPerTokenStored": [
    "function rewardPerTokenStored() external view returns (uint256);"
  ],
  "StakingRewards.__StakingRewards_init": [
    "function __StakingRewards_init(\n        address _stakingToken,\n        address _rewardToken,\n        uint256 _rewardsDuration\n    )\n        internal\n        onlyInitializing\n    {\n        stakeToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardsDuration = _rewardsDuration;\n    }"
  ],
  "StakingRewards.updateReward": [
    "modifier updateReward(address account) {\n        _updateReward(account);\n        _;\n    }"
  ],
  "StakingRewards._notifyRewardAmount": [
    "function _notifyRewardAmount(uint256 reward) internal virtual updateReward(address(0)) {\n        reward = reward * PRECISION;\n        if (totalSupply != 0 && block.timestamp < periodFinish) {\n            reward += _computeLeftOverReward();\n        }\n        undistributedRewards += reward;\n        _checkRewardSolvency();\n        if (totalSupply != 0) {\n            _setRewardRate();\n            lastUpdateTime = block.timestamp;\n        }\n        emit RewardAdded(reward);\n    }"
  ],
  "StakingRewards._checkRewardSolvency": [
    "function _checkRewardSolvency() internal view virtual {\n        if (undistributedRewards / PRECISION > rewardToken.balanceOf(address(this))) {\n            InsolventReward.selector.revertWith();\n        }\n    }"
  ],
  "StakingRewards._getReward": [
    "function _getReward(address account, address recipient) internal virtual updateReward(account) returns (uint256) {\n        Info storage info = _accountInfo[account];\n        uint256 reward = info.unclaimedReward; \n        if (reward != 0) {\n            info.unclaimedReward = 0;\n            _safeTransferRewardToken(recipient, reward);\n            emit RewardPaid(account, recipient, reward);\n        }\n        return reward;\n    }"
  ],
  "StakingRewards._safeTransferRewardToken": [
    "function _safeTransferRewardToken(address to, uint256 amount) internal virtual {\n        rewardToken.safeTransfer(to, amount);\n    }"
  ],
  "StakingRewards._stake": [
    "function _stake(address account, uint256 amount) internal virtual {\n        if (amount == 0) StakeAmountIsZero.selector.revertWith();\n        if (totalSupply == 0 && undistributedRewards > 0) {\n            _setRewardRate();\n        }\n        _updateReward(account);\n        unchecked {\n            uint256 totalSupplyBefore = totalSupply; \n            uint256 totalSupplyAfter = totalSupplyBefore + amount;\n            if (totalSupplyAfter <= totalSupplyBefore) TotalSupplyOverflow.selector.revertWith();\n            totalSupply = totalSupplyAfter;\n            _accountInfo[account].balance += amount;\n        }\n        _safeTransferFromStakeToken(msg.sender, amount);\n        emit Staked(account, amount);\n    }"
  ],
  "StakingRewards._safeTransferFromStakeToken": [
    "function _safeTransferFromStakeToken(address from, uint256 amount) internal virtual {\n        stakeToken.safeTransferFrom(from, address(this), amount);\n    }"
  ],
  "StakingRewards._withdraw": [
    "function _withdraw(address account, uint256 amount) internal virtual {\n        if (amount == 0) WithdrawAmountIsZero.selector.revertWith();\n        _updateReward(account);\n        unchecked {\n            Info storage info = _accountInfo[account];\n            uint256 balanceBefore = info.balance; \n            if (balanceBefore < amount) InsufficientStake.selector.revertWith();\n            info.balance = balanceBefore - amount;\n            totalSupply -= amount;\n        }\n        if (totalSupply == 0 && block.timestamp < periodFinish) {\n            undistributedRewards += _computeLeftOverReward();\n        }\n        _safeTransferStakeToken(msg.sender, amount);\n        emit Withdrawn(account, amount);\n    }"
  ],
  "StakingRewards._safeTransferStakeToken": [
    "function _safeTransferStakeToken(address to, uint256 amount) internal virtual {\n        stakeToken.safeTransfer(to, amount);\n    }"
  ],
  "StakingRewards._setRewardRate": [
    "function _setRewardRate() internal virtual {\n        uint256 _rewardsDuration = rewardsDuration; \n        uint256 _rewardRate = undistributedRewards / _rewardsDuration;\n        rewardRate = _rewardRate;\n        periodFinish = block.timestamp + _rewardsDuration;\n        undistributedRewards -= _rewardRate * _rewardsDuration;\n    }"
  ],
  "StakingRewards._updateReward": [
    "function _updateReward(address account) internal virtual {\n        uint256 _rewardPerToken = rewardPerToken(); \n        rewardPerTokenStored = _rewardPerToken;\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            Info storage info = _accountInfo[account];\n            (info.unclaimedReward, info.rewardsPerTokenPaid) = (earned(account), _rewardPerToken);\n        }\n    }"
  ],
  "StakingRewards._setRewardsDuration": [
    "function _setRewardsDuration(uint256 _rewardsDuration) internal virtual {\n        if (_rewardsDuration == 0) RewardsDurationIsZero.selector.revertWith();\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(_rewardsDuration);\n    }"
  ],
  "StakingRewards._computeLeftOverReward": [
    "function _computeLeftOverReward() internal view returns (uint256 leftOver) {\n        uint256 remainingTime;\n        unchecked {\n            remainingTime = periodFinish - block.timestamp;\n        }\n        leftOver = rewardRate * remainingTime;\n    }"
  ],
  "StakingRewards.balanceOf": [
    "function balanceOf(address account) public view virtual returns (uint256) {\n        return _accountInfo[account].balance;\n    }"
  ],
  "StakingRewards.rewards": [
    "function rewards(address account) public view virtual returns (uint256) {\n        return _accountInfo[account].unclaimedReward;\n    }"
  ],
  "StakingRewards.userRewardPerTokenPaid": [
    "function userRewardPerTokenPaid(address account) public view virtual returns (uint256) {\n        return _accountInfo[account].rewardsPerTokenPaid;\n    }"
  ],
  "StakingRewards.lastTimeRewardApplicable": [
    "function lastTimeRewardApplicable() public view virtual returns (uint256) {\n        return FixedPointMathLib.min(block.timestamp, periodFinish);\n    }"
  ],
  "StakingRewards.rewardPerToken": [
    "function rewardPerToken() public view virtual returns (uint256) {\n        uint256 _totalSupply = totalSupply; \n        if (_totalSupply == 0) return rewardPerTokenStored;\n        uint256 timeDelta;\n        unchecked {\n            timeDelta = lastTimeRewardApplicable() - lastUpdateTime;\n        }\n        uint256 _newRewardPerToken = FixedPointMathLib.fullMulDiv(rewardRate, timeDelta, _totalSupply);\n        return rewardPerTokenStored + _newRewardPerToken;\n    }"
  ],
  "StakingRewards.earned": [
    "function earned(address account) public view virtual returns (uint256) {\n        Info storage info = _accountInfo[account];\n        (uint256 balance, uint256 unclaimedReward, uint256 rewardsPerTokenPaid) =\n            (info.balance, info.unclaimedReward, info.rewardsPerTokenPaid);\n        uint256 rewardPerTokenDelta;\n        unchecked {\n            rewardPerTokenDelta = rewardPerToken() - rewardsPerTokenPaid;\n        }\n        return unclaimedReward + FixedPointMathLib.fullMulDiv(balance, rewardPerTokenDelta, PRECISION);\n    }"
  ],
  "StakingRewards.getRewardForDuration": [
    "function getRewardForDuration() public view virtual returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(rewardRate, rewardsDuration, PRECISION);\n    }"
  ],
  "FactoryOwnable.__FactoryOwnable_init": [
    "function __FactoryOwnable_init(address factoryAddr) internal onlyInitializing {\n        _setFactory(factoryAddr);\n    }"
  ],
  "FactoryOwnable.onlyFactoryOwner": [
    "modifier onlyFactoryOwner() {\n        _checkFactoryOwner();\n        _;\n    }"
  ],
  "FactoryOwnable.onlyFactoryVaultManager": [
    "modifier onlyFactoryVaultManager() {\n        _checkFactoryVaultManager();\n        _;\n    }"
  ],
  "FactoryOwnable.onlyFactoryVaultPauser": [
    "modifier onlyFactoryVaultPauser() {\n        _checkFactoryVaultPauser();\n        _;\n    }"
  ],
  "FactoryOwnable.factory": [
    "function factory() public view virtual returns (address) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return $._factory;\n    }"
  ],
  "FactoryOwnable.isFactoryOwner": [
    "function isFactoryOwner(address user) public view virtual returns (bool) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return AccessControlUpgradeable($._factory).hasRole(_getAdminRole(), user);\n    }"
  ],
  "FactoryOwnable.isFactoryVaultManager": [
    "function isFactoryVaultManager(address user) public view virtual returns (bool) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return AccessControlUpgradeable($._factory).hasRole(_getVaultManagerRole(), user);\n    }"
  ],
  "FactoryOwnable.isFactoryVaultPauser": [
    "function isFactoryVaultPauser(address user) public view virtual returns (bool) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return AccessControlUpgradeable($._factory).hasRole(_getVaultPauserRole(), user);\n    }"
  ],
  "FactoryOwnable._getAdminRole": [
    "function _getAdminRole() internal view returns (bytes32) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return AccessControlUpgradeable($._factory).DEFAULT_ADMIN_ROLE();\n    }"
  ],
  "FactoryOwnable._getVaultManagerRole": [
    "function _getVaultManagerRole() internal view returns (bytes32) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return IRewardVaultFactory($._factory).VAULT_MANAGER_ROLE();\n    }"
  ],
  "FactoryOwnable._getVaultPauserRole": [
    "function _getVaultPauserRole() internal view returns (bytes32) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return IRewardVaultFactory($._factory).VAULT_PAUSER_ROLE();\n    }"
  ],
  "FactoryOwnable._getFactoryOwnableStorage": [
    "function _getFactoryOwnableStorage() internal pure returns (FactoryOwnableStorage storage $) {\n        assembly {\n            $.slot := FactoryOwnableStorageLocation\n        }\n    }"
  ],
  "FactoryOwnable.getBGTIncentiveDistributor": [
    "function getBGTIncentiveDistributor() internal view returns (address) {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        return IRewardVaultFactory($._factory).bgtIncentiveDistributor();\n    }"
  ],
  "FactoryOwnable._setFactory": [
    "function _setFactory(address factoryAddr) internal {\n        FactoryOwnableStorage storage $ = _getFactoryOwnableStorage();\n        $._factory = factoryAddr;\n    }"
  ],
  "FactoryOwnable._checkFactoryOwner": [
    "function _checkFactoryOwner() internal view {\n        if (!isFactoryOwner(msg.sender)) OwnableUnauthorizedAccount.selector.revertWith(msg.sender);\n    }"
  ],
  "FactoryOwnable._checkFactoryVaultManager": [
    "function _checkFactoryVaultManager() internal view {\n        if (!isFactoryVaultManager(msg.sender)) OwnableUnauthorizedAccount.selector.revertWith(msg.sender);\n    }"
  ],
  "FactoryOwnable._checkFactoryVaultPauser": [
    "function _checkFactoryVaultPauser() internal view {\n        if (!isFactoryVaultPauser(msg.sender)) OwnableUnauthorizedAccount.selector.revertWith(msg.sender);\n    }"
  ],
  "BeraChef_V1.initialize": [
    "function initialize(\n        address _distributor,\n        address _factory,\n        address _governance,\n        address _beaconDepositContract,\n        uint8 _maxNumWeightsPerRewardAllocation\n    )\n        external\n        initializer\n    {\n        __Ownable_init(_governance);\n        __UUPSUpgradeable_init();\n        distributor = _distributor;\n        factory = _factory;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        if (_maxNumWeightsPerRewardAllocation == 0) {\n            MaxNumWeightsPerRewardAllocationIsZero.selector.revertWith();\n        }\n        emit MaxNumWeightsPerRewardAllocationSet(_maxNumWeightsPerRewardAllocation);\n        maxNumWeightsPerRewardAllocation = _maxNumWeightsPerRewardAllocation;\n    }"
  ],
  "BeraChef_V1._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }"
  ],
  "BeraChef_V1.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) {\n            NotDistributor.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "BeraChef_V1.onlyOperator": [
    "modifier onlyOperator(bytes calldata valPubkey) {\n        if (msg.sender != beaconDepositContract.getOperator(valPubkey)) {\n            NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "BeraChef_V1.setMaxNumWeightsPerRewardAllocation": [
    "function setMaxNumWeightsPerRewardAllocation(uint8 _maxNumWeightsPerRewardAllocation) external onlyOwner {\n        if (_maxNumWeightsPerRewardAllocation == 0) {\n            MaxNumWeightsPerRewardAllocationIsZero.selector.revertWith();\n        }\n        if (_maxNumWeightsPerRewardAllocation < defaultRewardAllocation.weights.length) {\n            InvalidateDefaultRewardAllocation.selector.revertWith();\n        }\n        maxNumWeightsPerRewardAllocation = _maxNumWeightsPerRewardAllocation;\n        emit MaxNumWeightsPerRewardAllocationSet(_maxNumWeightsPerRewardAllocation);\n    }"
  ],
  "BeraChef_V1.setRewardAllocationBlockDelay": [
    "function setRewardAllocationBlockDelay(uint64 _rewardAllocationBlockDelay) external onlyOwner {\n        if (_rewardAllocationBlockDelay > MAX_REWARD_ALLOCATION_BLOCK_DELAY) {\n            RewardAllocationBlockDelayTooLarge.selector.revertWith();\n        }\n        rewardAllocationBlockDelay = _rewardAllocationBlockDelay;\n        emit RewardAllocationBlockDelaySet(_rewardAllocationBlockDelay);\n    }"
  ],
  "BeraChef_V1.setVaultWhitelistedStatus": [
    "function setVaultWhitelistedStatus(\n        address receiver,\n        bool isWhitelisted,\n        string memory metadata\n    )\n        external\n        onlyOwner\n    {\n        address stakeToken = address(RewardVault(receiver).stakeToken());\n        address factoryVault = IRewardVaultFactory(factory).getVault(stakeToken);\n        if (receiver != factoryVault) {\n            NotFactoryVault.selector.revertWith();\n        }\n        isWhitelistedVault[receiver] = isWhitelisted;\n        if (!isWhitelisted) {\n            if (!_checkIfStillValid(defaultRewardAllocation.weights)) {\n                InvalidRewardAllocationWeights.selector.revertWith();\n            }\n        }\n        emit VaultWhitelistedStatusUpdated(receiver, isWhitelisted, metadata);\n    }"
  ],
  "BeraChef_V1.updateWhitelistedVaultMetadata": [
    "function updateWhitelistedVaultMetadata(address vault, string memory metadata) external onlyOwner {\n        if (!isWhitelistedVault[vault]) {\n            NotWhitelistedVault.selector.revertWith();\n        }\n        emit WhitelistedVaultMetadataUpdated(vault, metadata);\n    }"
  ],
  "BeraChef_V1.setDefaultRewardAllocation": [
    "function setDefaultRewardAllocation(RewardAllocation calldata ra) external onlyOwner {\n        _validateWeights(ra.weights);\n        emit SetDefaultRewardAllocation(ra);\n        defaultRewardAllocation = ra;\n    }"
  ],
  "BeraChef_V1.setCommissionChangeDelay": [
    "function setCommissionChangeDelay(uint64 _commissionChangeDelay) external onlyOwner {\n        if (_commissionChangeDelay == 0 || _commissionChangeDelay > MAX_COMMISSION_CHANGE_DELAY) {\n            InvalidCommissionChangeDelay.selector.revertWith();\n        }\n        commissionChangeDelay = _commissionChangeDelay;\n        emit CommissionChangeDelaySet(_commissionChangeDelay);\n    }"
  ],
  "BeraChef_V1.queueNewRewardAllocation": [
    "function queueNewRewardAllocation(\n        bytes calldata valPubkey,\n        uint64 startBlock,\n        Weight[] calldata weights\n    )\n        external\n        onlyOperator(valPubkey)\n    {\n        if (startBlock <= block.number + rewardAllocationBlockDelay) {\n            InvalidStartBlock.selector.revertWith();\n        }\n        RewardAllocation storage qra = queuedRewardAllocations[valPubkey];\n        if (qra.startBlock > 0) {\n            RewardAllocationAlreadyQueued.selector.revertWith();\n        }\n        _validateWeights(weights);\n        qra.startBlock = startBlock;\n        Weight[] storage storageWeights = qra.weights;\n        for (uint256 i; i < weights.length;) {\n            storageWeights.push(weights[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        emit QueueRewardAllocation(valPubkey, startBlock, weights);\n    }"
  ],
  "BeraChef_V1.queueValCommission": [
    "function queueValCommission(bytes calldata valPubkey, uint96 commissionRate) external onlyOperator(valPubkey) {\n        if (commissionRate > ONE_HUNDRED_PERCENT) {\n            InvalidCommissionValue.selector.revertWith();\n        }\n        QueuedCommissionRateChange storage qcr = valQueuedCommission[valPubkey];\n        if (qcr.blockNumberLast > 0) {\n            CommissionChangeAlreadyQueued.selector.revertWith();\n        }\n        (qcr.blockNumberLast, qcr.commissionRate) = (uint32(block.number), commissionRate);\n        emit QueuedValCommission(valPubkey, commissionRate);\n    }"
  ],
  "BeraChef_V1.activateQueuedValCommission": [
    "function activateQueuedValCommission(bytes calldata valPubkey) external {\n        QueuedCommissionRateChange storage qcr = valQueuedCommission[valPubkey];\n        (uint32 blockNumberLast, uint96 commissionRate) = (qcr.blockNumberLast, qcr.commissionRate);\n        uint32 activationBlock = uint32(blockNumberLast + commissionChangeDelay);\n        if (blockNumberLast == 0 || block.number < activationBlock) {\n            CommissionNotQueuedOrDelayNotPassed.selector.revertWith();\n        }\n        uint96 oldCommission = _getOperatorCommission(valPubkey);\n        valCommission[valPubkey] = CommissionRate({ activationBlock: activationBlock, commissionRate: commissionRate });\n        emit ValCommissionSet(valPubkey, oldCommission, commissionRate);\n        delete valQueuedCommission[valPubkey];\n    }"
  ],
  "BeraChef_V1.activateReadyQueuedRewardAllocation": [
    "function activateReadyQueuedRewardAllocation(bytes calldata valPubkey) external onlyDistributor {\n        if (!isQueuedRewardAllocationReady(valPubkey, block.number)) return;\n        RewardAllocation storage qra = queuedRewardAllocations[valPubkey];\n        uint64 startBlock = qra.startBlock;\n        activeRewardAllocations[valPubkey] = qra;\n        emit ActivateRewardAllocation(valPubkey, startBlock, qra.weights);\n        delete queuedRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef_V1.getActiveRewardAllocation": [
    "function getActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        RewardAllocation memory ara = activeRewardAllocations[valPubkey];\n        if (ara.startBlock > 0 && _checkIfStillValid(ara.weights)) {\n            return ara;\n        }\n        return defaultRewardAllocation;\n    }"
  ],
  "BeraChef_V1.getQueuedRewardAllocation": [
    "function getQueuedRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        return queuedRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef_V1.getSetActiveRewardAllocation": [
    "function getSetActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory) {\n        return activeRewardAllocations[valPubkey];\n    }"
  ],
  "BeraChef_V1.getDefaultRewardAllocation": [
    "function getDefaultRewardAllocation() external view returns (RewardAllocation memory) {\n        return defaultRewardAllocation;\n    }"
  ],
  "BeraChef_V1.isQueuedRewardAllocationReady": [
    "function isQueuedRewardAllocationReady(bytes calldata valPubkey, uint256 blockNumber) public view returns (bool) {\n        uint64 startBlock = queuedRewardAllocations[valPubkey].startBlock;\n        return startBlock != 0 && startBlock <= blockNumber;\n    }"
  ],
  "BeraChef_V1.isReady": [
    "function isReady() external view returns (bool) {\n        return defaultRewardAllocation.weights.length > 0;\n    }"
  ],
  "BeraChef_V1.getValCommissionOnIncentiveTokens": [
    "function getValCommissionOnIncentiveTokens(bytes calldata valPubkey) external view returns (uint96) {\n        return _getOperatorCommission(valPubkey);\n    }"
  ],
  "BeraChef_V1.getValQueuedCommissionOnIncentiveTokens": [
    "function getValQueuedCommissionOnIncentiveTokens(bytes calldata valPubkey)\n        external\n        view\n        returns (QueuedCommissionRateChange memory)\n    {\n        return valQueuedCommission[valPubkey];\n    }"
  ],
  "BeraChef_V1.getValidatorIncentiveTokenShare": [
    "function getValidatorIncentiveTokenShare(\n        bytes calldata valPubkey,\n        uint256 incentiveTokenAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint96 operatorCommission = _getOperatorCommission(valPubkey);\n        uint256 operatorShare = (incentiveTokenAmount * operatorCommission) / ONE_HUNDRED_PERCENT;\n        return operatorShare;\n    }"
  ],
  "BeraChef_V1._validateWeights": [
    "function _validateWeights(Weight[] calldata weights) internal view {\n        if (weights.length > maxNumWeightsPerRewardAllocation) {\n            TooManyWeights.selector.revertWith();\n        }\n        uint96 totalWeight;\n        for (uint256 i; i < weights.length;) {\n            Weight calldata weight = weights[i];\n            if (weight.percentageNumerator == 0) {\n                ZeroPercentageWeight.selector.revertWith();\n            }\n            if (!isWhitelistedVault[weight.receiver]) {\n                NotWhitelistedVault.selector.revertWith();\n            }\n            totalWeight += weight.percentageNumerator;\n            unchecked {\n                ++i;\n            }\n        }\n        if (totalWeight != ONE_HUNDRED_PERCENT) {\n            InvalidRewardAllocationWeights.selector.revertWith();\n        }\n    }"
  ],
  "BeraChef_V1._checkIfStillValid": [
    "function _checkIfStillValid(Weight[] memory weights) internal view returns (bool) {\n        uint256 length = weights.length;\n        if (length > maxNumWeightsPerRewardAllocation) {\n            return false;\n        }\n        for (uint256 i; i < length;) {\n            if (!isWhitelistedVault[weights[i].receiver]) {\n                return false;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }"
  ],
  "BeraChef_V1._getOperatorCommission": [
    "function _getOperatorCommission(bytes calldata valPubkey) internal view returns (uint96) {\n        CommissionRate memory operatorCommission = valCommission[valPubkey];\n        if (operatorCommission.activationBlock == 0) return DEFAULT_COMMISSION_RATE;\n        return operatorCommission.commissionRate;\n    }"
  ],
  "RewardVault_V1.initialize": [
    "function initialize(\n        address _beaconDepositContract,\n        address _bgt,\n        address _distributor,\n        address _stakingToken\n    )\n        external\n        initializer\n    {\n        __FactoryOwnable_init(msg.sender);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __StakingRewards_init(_stakingToken, _bgt, 7 days);\n        maxIncentiveTokensCount = 2;\n        distributor = _distributor;\n        beaconDepositContract = IBeaconDeposit(_beaconDepositContract);\n        emit DistributorSet(_distributor);\n        emit MaxIncentiveTokensCountUpdated(2);\n    }"
  ],
  "RewardVault_V1.onlyDistributor": [
    "modifier onlyDistributor() {\n        if (msg.sender != distributor) NotDistributor.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V1.onlyOperatorOrUser": [
    "modifier onlyOperatorOrUser(address account) {\n        if (msg.sender != account) {\n            if (msg.sender != _operators[account]) NotOperator.selector.revertWith();\n        }\n        _;\n    }"
  ],
  "RewardVault_V1.checkSelfStakedBalance": [
    "modifier checkSelfStakedBalance(address account, uint256 amount) {\n        _checkSelfStakedBalance(account, amount);\n        _;\n    }"
  ],
  "RewardVault_V1.onlyWhitelistedToken": [
    "modifier onlyWhitelistedToken(address token) {\n        if (incentives[token].minIncentiveRate == 0) TokenNotWhitelisted.selector.revertWith();\n        _;\n    }"
  ],
  "RewardVault_V1.setDistributor": [
    "function setDistributor(address _rewardDistribution) external onlyFactoryOwner {\n        if (_rewardDistribution == address(0)) ZeroAddress.selector.revertWith();\n        distributor = _rewardDistribution;\n        emit DistributorSet(_rewardDistribution);\n    }"
  ],
  "RewardVault_V1.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external onlyDistributor {\n        _notifyRewardAmount(reward);\n        _processIncentives(pubkey, reward);\n    }"
  ],
  "RewardVault_V1.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyFactoryOwner {\n        if (tokenAddress == address(stakeToken)) CannotRecoverStakingToken.selector.revertWith();\n        if (incentives[tokenAddress].minIncentiveRate != 0) CannotRecoverIncentiveToken.selector.revertWith();\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }"
  ],
  "RewardVault_V1.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external onlyFactoryOwner {\n        _setRewardsDuration(_rewardsDuration);\n    }"
  ],
  "RewardVault_V1.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(\n        address token,\n        uint256 minIncentiveRate,\n        address manager\n    )\n        external\n        onlyFactoryOwner\n    {\n        if (minIncentiveRate == 0) MinIncentiveRateIsZero.selector.revertWith();\n        if (minIncentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        if (token == address(0) || manager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        if (whitelistedTokens.length == maxIncentiveTokensCount || incentive.minIncentiveRate != 0) {\n            TokenAlreadyWhitelistedOrLimitReached.selector.revertWith();\n        }\n        whitelistedTokens.push(token);\n        incentive.incentiveRate = minIncentiveRate;\n        incentive.minIncentiveRate = minIncentiveRate;\n        incentive.manager = manager;\n        emit IncentiveTokenWhitelisted(token, minIncentiveRate, manager);\n    }"
  ],
  "RewardVault_V1.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external onlyFactoryVaultManager onlyWhitelistedToken(token) {\n        delete incentives[token];\n        _deleteWhitelistedTokenFromList(token);\n        emit IncentiveTokenRemoved(token);\n    }"
  ],
  "RewardVault_V1.updateIncentiveManager": [
    "function updateIncentiveManager(\n        address token,\n        address newManager\n    )\n        external\n        onlyFactoryOwner\n        onlyWhitelistedToken(token)\n    {\n        if (newManager == address(0)) ZeroAddress.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        address currentManager = incentive.manager;\n        incentive.manager = newManager;\n        emit IncentiveManagerChanged(token, newManager, currentManager);\n    }"
  ],
  "RewardVault_V1.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external onlyFactoryOwner {\n        if (_maxIncentiveTokensCount < whitelistedTokens.length) {\n            InvalidMaxIncentiveTokensCount.selector.revertWith();\n        }\n        maxIncentiveTokensCount = _maxIncentiveTokensCount;\n        emit MaxIncentiveTokensCountUpdated(_maxIncentiveTokensCount);\n    }"
  ],
  "RewardVault_V1.pause": [
    "function pause() external onlyFactoryVaultPauser {\n        _pause();\n    }"
  ],
  "RewardVault_V1.unpause": [
    "function unpause() external onlyFactoryVaultManager {\n        _unpause();\n    }"
  ],
  "RewardVault_V1.operator": [
    "function operator(address account) external view returns (address) {\n        return _operators[account];\n    }"
  ],
  "RewardVault_V1.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256) {\n        return whitelistedTokens.length;\n    }"
  ],
  "RewardVault_V1.getWhitelistedTokens": [
    "function getWhitelistedTokens() public view returns (address[] memory) {\n        return whitelistedTokens;\n    }"
  ],
  "RewardVault_V1.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256) {\n        return _delegateStake[account].delegateTotalStaked;\n    }"
  ],
  "RewardVault_V1.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256) {\n        return _delegateStake[account].stakedByDelegate[delegate];\n    }"
  ],
  "RewardVault_V1.stake": [
    "function stake(uint256 amount) external nonReentrant whenNotPaused {\n        _stake(msg.sender, amount);\n    }"
  ],
  "RewardVault_V1.delegateStake": [
    "function delegateStake(address account, uint256 amount) external nonReentrant whenNotPaused {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        _stake(account, amount);\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            info.delegateTotalStaked += amount;\n            info.stakedByDelegate[msg.sender] += amount;\n        }\n        emit DelegateStaked(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V1.withdraw": [
    "function withdraw(uint256 amount) external nonReentrant checkSelfStakedBalance(msg.sender, amount) {\n        _withdraw(msg.sender, amount);\n    }"
  ],
  "RewardVault_V1.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external nonReentrant {\n        if (msg.sender == account) NotDelegate.selector.revertWith();\n        unchecked {\n            DelegateStake storage info = _delegateStake[account];\n            uint256 stakedByDelegate = info.stakedByDelegate[msg.sender];\n            if (stakedByDelegate < amount) InsufficientDelegateStake.selector.revertWith();\n            info.stakedByDelegate[msg.sender] = stakedByDelegate - amount;\n            info.delegateTotalStaked -= amount;\n        }\n        _withdraw(account, amount);\n        emit DelegateWithdrawn(account, msg.sender, amount);\n    }"
  ],
  "RewardVault_V1.getReward": [
    "function getReward(\n        address account,\n        address recipient\n    )\n        external\n        nonReentrant\n        onlyOperatorOrUser(account)\n        returns (uint256)\n    {\n        return _getReward(account, recipient);\n    }"
  ],
  "RewardVault_V1.exit": [
    "function exit(address recipient) external nonReentrant {\n        uint256 amount = _accountInfo[msg.sender].balance - _delegateStake[msg.sender].delegateTotalStaked;\n        _withdraw(msg.sender, amount);\n        _getReward(msg.sender, recipient);\n    }"
  ],
  "RewardVault_V1.setOperator": [
    "function setOperator(address _operator) external {\n        _operators[msg.sender] = _operator;\n        emit OperatorSet(msg.sender, _operator);\n    }"
  ],
  "RewardVault_V1.addIncentive": [
    "function addIncentive(\n        address token,\n        uint256 amount,\n        uint256 incentiveRate\n    )\n        external\n        nonReentrant\n        onlyWhitelistedToken(token)\n    {\n        if (incentiveRate > MAX_INCENTIVE_RATE) IncentiveRateTooHigh.selector.revertWith();\n        Incentive storage incentive = incentives[token];\n        (uint256 minIncentiveRate, uint256 incentiveRateStored, uint256 amountRemainingBefore, address manager) =\n            (incentive.minIncentiveRate, incentive.incentiveRate, incentive.amountRemaining, incentive.manager);\n        if (msg.sender != manager) NotIncentiveManager.selector.revertWith();\n        if (amount < minIncentiveRate) AmountLessThanMinIncentiveRate.selector.revertWith();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        incentive.amountRemaining = amountRemainingBefore + amount;\n        if (amountRemainingBefore == 0 && incentiveRate >= minIncentiveRate) {\n            incentive.incentiveRate = incentiveRate;\n        }\n        else if (incentiveRate > incentiveRateStored) {\n            uint256 rateDelta;\n            unchecked {\n                rateDelta = incentiveRate - incentiveRateStored;\n            }\n            if (amount >= FixedPointMathLib.mulDiv(amountRemainingBefore, rateDelta, incentiveRateStored)) {\n                incentive.incentiveRate = incentiveRate;\n            }\n        }\n        emit IncentiveAdded(token, msg.sender, amount, incentive.incentiveRate);\n    }"
  ],
  "RewardVault_V1._checkSelfStakedBalance": [
    "function _checkSelfStakedBalance(address account, uint256 amount) internal view {\n        unchecked {\n            uint256 selfStaked = _accountInfo[account].balance - _delegateStake[account].delegateTotalStaked;\n            if (selfStaked < amount) InsufficientSelfStake.selector.revertWith();\n        }\n    }"
  ],
  "RewardVault_V1._safeTransferRewardToken": [
    "function _safeTransferRewardToken(address to, uint256 amount) internal override {\n        rewardToken.safeTransferFrom(distributor, to, amount);\n    }"
  ],
  "RewardVault_V1._checkRewardSolvency": [
    "function _checkRewardSolvency() internal view override {\n        uint256 allowance = rewardToken.allowance(distributor, address(this));\n        if (undistributedRewards / PRECISION > allowance) InsolventReward.selector.revertWith();\n    }"
  ],
  "RewardVault_V1._processIncentives": [
    "function _processIncentives(bytes calldata pubkey, uint256 bgtEmitted) internal {\n        address _operator = beaconDepositContract.getOperator(pubkey);\n        IBeraChef beraChef = IDistributor(distributor).beraChef();\n        address bgtIncentiveDistributor = getBGTIncentiveDistributor();\n        uint256 whitelistedTokensCount = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < whitelistedTokensCount; ++i) {\n                address token = whitelistedTokens[i];\n                Incentive storage incentive = incentives[token];\n                uint256 amount = FixedPointMathLib.mulDiv(bgtEmitted, incentive.incentiveRate, PRECISION);\n                uint256 amountRemaining = incentive.amountRemaining;\n                amount = FixedPointMathLib.min(amount, amountRemaining);\n                uint256 validatorShare;\n                if (amount > 0) {\n                    validatorShare = beraChef.getValidatorIncentiveTokenShare(pubkey, amount);\n                    amount -= validatorShare;\n                }\n                if (validatorShare > 0) {\n                    bool success = token.trySafeTransfer(_operator, validatorShare);\n                    if (success) {\n                        amountRemaining -= validatorShare;\n                        emit IncentivesProcessed(pubkey, token, bgtEmitted, validatorShare);\n                    } else {\n                        emit IncentivesProcessFailed(pubkey, token, bgtEmitted, validatorShare);\n                    }\n                }\n                if (amount > 0) {\n                    bytes memory data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, amount));\n                    (bool success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                    if (success) {\n                        data = abi.encodeCall(IBGTIncentiveDistributor.receiveIncentive, (pubkey, token, amount));\n                        (success,) = bgtIncentiveDistributor.call{ gas: SAFE_GAS_LIMIT }(data);\n                        if (success) {\n                            amountRemaining -= amount;\n                            emit BGTBoosterIncentivesProcessed(pubkey, token, bgtEmitted, amount);\n                        } else {\n                            data = abi.encodeCall(IERC20.approve, (bgtIncentiveDistributor, 0));\n                            (success,) = token.call{ gas: SAFE_GAS_LIMIT }(data);\n                            emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                        }\n                    }\n                    else {\n                        emit BGTBoosterIncentivesProcessFailed(pubkey, token, bgtEmitted, amount);\n                    }\n                }\n                incentive.amountRemaining = amountRemaining;\n            }\n        }\n    }"
  ],
  "RewardVault_V1._deleteWhitelistedTokenFromList": [
    "function _deleteWhitelistedTokenFromList(address token) internal {\n        uint256 activeTokens = whitelistedTokens.length;\n        unchecked {\n            for (uint256 i; i < activeTokens; ++i) {\n                if (token == whitelistedTokens[i]) {\n                    whitelistedTokens[i] = whitelistedTokens[activeTokens - 1];\n                    whitelistedTokens.pop();\n                    return;\n                }\n            }\n        }\n    }"
  ],
  "IRewardVault_V1.distributor": [
    "function distributor() external view returns (address);"
  ],
  "IRewardVault_V1.operator": [
    "function operator(address account) external view returns (address);"
  ],
  "IRewardVault_V1.getWhitelistedTokensCount": [
    "function getWhitelistedTokensCount() external view returns (uint256);"
  ],
  "IRewardVault_V1.getWhitelistedTokens": [
    "function getWhitelistedTokens() external view returns (address[] memory);"
  ],
  "IRewardVault_V1.getTotalDelegateStaked": [
    "function getTotalDelegateStaked(address account) external view returns (uint256);"
  ],
  "IRewardVault_V1.getDelegateStake": [
    "function getDelegateStake(address account, address delegate) external view returns (uint256);"
  ],
  "IRewardVault_V1.initialize": [
    "function initialize(address _berachef, address _bgt, address _distributor, address _stakingToken) external;"
  ],
  "IRewardVault_V1.setDistributor": [
    "function setDistributor(address _rewardDistribution) external;"
  ],
  "IRewardVault_V1.notifyRewardAmount": [
    "function notifyRewardAmount(bytes calldata pubkey, uint256 reward) external;"
  ],
  "IRewardVault_V1.recoverERC20": [
    "function recoverERC20(address tokenAddress, uint256 tokenAmount) external;"
  ],
  "IRewardVault_V1.setRewardsDuration": [
    "function setRewardsDuration(uint256 _rewardsDuration) external;"
  ],
  "IRewardVault_V1.whitelistIncentiveToken": [
    "function whitelistIncentiveToken(address token, uint256 minIncentiveRate, address manager) external;"
  ],
  "IRewardVault_V1.removeIncentiveToken": [
    "function removeIncentiveToken(address token) external;"
  ],
  "IRewardVault_V1.setMaxIncentiveTokensCount": [
    "function setMaxIncentiveTokensCount(uint8 _maxIncentiveTokensCount) external;"
  ],
  "IRewardVault_V1.pause": [
    "function pause() external;"
  ],
  "IRewardVault_V1.unpause": [
    "function unpause() external;"
  ],
  "IRewardVault_V1.exit": [
    "function exit(address recipient) external;"
  ],
  "IRewardVault_V1.getReward": [
    "function getReward(address account, address recipient) external returns (uint256);"
  ],
  "IRewardVault_V1.stake": [
    "function stake(uint256 amount) external;"
  ],
  "IRewardVault_V1.delegateStake": [
    "function delegateStake(address account, uint256 amount) external;"
  ],
  "IRewardVault_V1.withdraw": [
    "function withdraw(uint256 amount) external;"
  ],
  "IRewardVault_V1.delegateWithdraw": [
    "function delegateWithdraw(address account, uint256 amount) external;"
  ],
  "IRewardVault_V1.setOperator": [
    "function setOperator(address _operator) external;"
  ],
  "IRewardVault_V1.updateIncentiveManager": [
    "function updateIncentiveManager(address token, address newManager) external;"
  ],
  "IRewardVault_V1.addIncentive": [
    "function addIncentive(address token, uint256 amount, uint256 incentiveRate) external;"
  ],
  "IBeraChef_V1.getActiveRewardAllocation": [
    "function getActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V1.getQueuedRewardAllocation": [
    "function getQueuedRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V1.getSetActiveRewardAllocation": [
    "function getSetActiveRewardAllocation(bytes calldata valPubkey) external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V1.getDefaultRewardAllocation": [
    "function getDefaultRewardAllocation() external view returns (RewardAllocation memory);"
  ],
  "IBeraChef_V1.isQueuedRewardAllocationReady": [
    "function isQueuedRewardAllocationReady(\n        bytes calldata valPubkey,\n        uint256 blockNumber\n    )\n        external\n        view\n        returns (bool);"
  ],
  "IBeraChef_V1.isReady": [
    "function isReady() external view returns (bool);"
  ],
  "IBeraChef_V1.getValQueuedCommissionOnIncentiveTokens": [
    "function getValQueuedCommissionOnIncentiveTokens(bytes calldata valPubkey)\n        external\n        view\n        returns (QueuedCommissionRateChange memory);"
  ],
  "IBeraChef_V1.getValCommissionOnIncentiveTokens": [
    "function getValCommissionOnIncentiveTokens(bytes calldata valPubkey) external view returns (uint96);"
  ],
  "IBeraChef_V1.getValidatorIncentiveTokenShare": [
    "function getValidatorIncentiveTokenShare(\n        bytes calldata valPubkey,\n        uint256 incentiveTokenAmount\n    )\n        external\n        view\n        returns (uint256);"
  ],
  "IBeraChef_V1.setMaxNumWeightsPerRewardAllocation": [
    "function setMaxNumWeightsPerRewardAllocation(uint8 _maxNumWeightsPerRewardAllocation) external;"
  ],
  "IBeraChef_V1.setRewardAllocationBlockDelay": [
    "function setRewardAllocationBlockDelay(uint64 _rewardAllocationBlockDelay) external;"
  ],
  "IBeraChef_V1.setVaultWhitelistedStatus": [
    "function setVaultWhitelistedStatus(address receiver, bool isWhitelisted, string memory metadata) external;"
  ],
  "IBeraChef_V1.updateWhitelistedVaultMetadata": [
    "function updateWhitelistedVaultMetadata(address receiver, string memory metadata) external;"
  ],
  "IBeraChef_V1.setDefaultRewardAllocation": [
    "function setDefaultRewardAllocation(RewardAllocation calldata rewardAllocation) external;"
  ],
  "IBeraChef_V1.queueNewRewardAllocation": [
    "function queueNewRewardAllocation(\n        bytes calldata valPubkey,\n        uint64 startBlock,\n        Weight[] calldata weights\n    )\n        external;"
  ],
  "IBeraChef_V1.activateReadyQueuedRewardAllocation": [
    "function activateReadyQueuedRewardAllocation(bytes calldata valPubkey) external;"
  ],
  "IBeraChef_V1.setCommissionChangeDelay": [
    "function setCommissionChangeDelay(uint64 _commissionChangeDelay) external;"
  ],
  "IBeraChef_V1.queueValCommission": [
    "function queueValCommission(bytes calldata valPubkey, uint96 commissionRate) external;"
  ],
  "IBeraChef_V1.activateQueuedValCommission": [
    "function activateQueuedValCommission(bytes calldata valPubkey) external;"
  ],
  "TimeLock._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }"
  ],
  "BerachainGovernance.initialize": [
    "function initialize(\n        IVotes _token,\n        TimelockControllerUpgradeable _timelock,\n        InitialGovernorParameters memory params\n    )\n        public\n        initializer\n    {\n        __UUPSUpgradeable_init();\n        __Governor_init(\"BerachainGovernance\");\n        __GovernorSettings_init(params.votingDelay, params.votingPeriod, params.proposalThreshold);\n        __GovernorCountingSimple_init();\n        __GovernorStorage_init();\n        __GovernorVotes_init(_token);\n        __GovernorVotesQuorumFraction_init(params.quorumNumeratorValue);\n        __GovernorTimelockControl_init(_timelock);\n    }"
  ],
  "BerachainGovernance._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal override onlyGovernance { }"
  ],
  "BerachainGovernance._voteSucceeded": [
    "function _voteSucceeded(uint256 proposalId)\n        internal\n        view\n        virtual\n        override(GovernorUpgradeable, GovernorCountingSimpleUpgradeable)\n        returns (bool)\n    {\n        (uint256 againstVotes, uint256 forVotes,) = proposalVotes(proposalId);\n        uint256 threshold = (forVotes + againstVotes) * 51 / 100;\n        return forVotes >= threshold;\n    }"
  ],
  "BerachainGovernance.getTimelockOperationId": [
    "function getTimelockOperationId(uint256 proposalId) external view returns (bytes32 operationId) {\n        TimelockControllerUpgradeable timelock = TimelockControllerUpgradeable(payable(_executor()));\n        (address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash) =\n            proposalDetails(proposalId);\n        bytes32 salt = bytes20(address(this)) ^ descriptionHash;\n        operationId = timelock.hashOperationBatch(targets, values, calldatas, 0, salt);\n    }"
  ],
  "BerachainGovernance._countVote": [
    "function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    )\n        internal\n        override(GovernorUpgradeable, GovernorCountingSimpleUpgradeable)\n        returns (uint256)\n    {\n        if (totalWeight == 0) {\n            GovernorZeroVoteWeight.selector.revertWith();\n        }\n        return GovernorCountingSimpleUpgradeable._countVote(proposalId, account, support, totalWeight, params);\n    }"
  ],
  "BerachainGovernance.state": [
    "function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return GovernorTimelockControlUpgradeable.state(proposalId);\n    }"
  ],
  "BerachainGovernance.proposalNeedsQueuing": [
    "function proposalNeedsQueuing(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return GovernorTimelockControlUpgradeable.proposalNeedsQueuing(proposalId);\n    }"
  ],
  "BerachainGovernance.proposalThreshold": [
    "function proposalThreshold()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return GovernorSettingsUpgradeable.proposalThreshold();\n    }"
  ],
  "BerachainGovernance._propose": [
    "function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    )\n        internal\n        override(GovernorUpgradeable, GovernorStorageUpgradeable)\n        returns (uint256)\n    {\n        return GovernorStorageUpgradeable._propose(targets, values, calldatas, description, proposer);\n    }"
  ],
  "BerachainGovernance._queueOperations": [
    "function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (uint48)\n    {\n        return GovernorTimelockControlUpgradeable._queueOperations(\n            proposalId, targets, values, calldatas, descriptionHash\n        );\n    }"
  ],
  "BerachainGovernance._executeOperations": [
    "function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n    {\n        GovernorTimelockControlUpgradeable._executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n    }"
  ],
  "BerachainGovernance._cancel": [
    "function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (uint256)\n    {\n        return GovernorTimelockControlUpgradeable._cancel(targets, values, calldatas, descriptionHash);\n    }"
  ],
  "BerachainGovernance._executor": [
    "function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return GovernorTimelockControlUpgradeable._executor();\n    }"
  ],
  "GovDeployer._deploy": [
    "function _deploy(bytes memory creationCode, uint256 salt) internal returns (address payable proxy) {\n        address impl = deployWithCreate2(salt, creationCode);\n        proxy = payable(deployProxyWithCreate2(impl, salt));\n    }"
  ],
  "GovDeployer._checkIfERC20Votes": [
    "function _checkIfERC20Votes(address token) internal view {\n        if (!_supportsERC20VotesAndMetadata(token)) {\n            revert(\"GovDeployer: token is not a valid ERC20Votes or ERC20Metadata\");\n        }\n    }"
  ],
  "GovDeployer._supportsERC20VotesAndMetadata": [
    "function _supportsERC20VotesAndMetadata(address token) internal view returns (bool) {\n        try IVotes(token).getVotes(address(this)) {\n            IERC20Metadata(token).name();\n            IERC20Metadata(token).decimals();\n            return true;\n        } catch {\n            return false;\n        }\n    }"
  ],
  "PeggedPriceOracle._priceData": [
    "function _priceData() internal view returns (IPriceOracle.Data memory) {\n        return IPriceOracle.Data({ price: 1e18, publishTime: block.timestamp });\n    }"
  ],
  "PeggedPriceOracle.getPrice": [
    "function getPrice(address asset) external view returns (Data memory data) {\n        asset;\n        return _priceData();\n    }"
  ],
  "PeggedPriceOracle.getPriceUnsafe": [
    "function getPriceUnsafe(address asset) external view returns (Data memory data) {\n        asset;\n        return _priceData();\n    }"
  ],
  "PeggedPriceOracle.getPriceNoOlderThan": [
    "function getPriceNoOlderThan(address asset, uint256 age) external view returns (Data memory data) {\n        asset;\n        age;\n        return _priceData();\n    }"
  ],
  "PeggedPriceOracle.priceAvailable": [
    "function priceAvailable(address asset) external pure returns (bool) {\n        asset;\n        return true;\n    }"
  ],
  "RootPriceOracle.initialize": [
    "function initialize(address initialAdmin) external initializer {\n        if (initialAdmin == address(0)) ZeroAddress.selector.revertWith();\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\n    }"
  ],
  "RootPriceOracle.setSpotOracle": [
    "function setSpotOracle(address spotOracle_) external onlyRole(MANAGER_ROLE) {\n        if (spotOracle_ == address(0)) ZeroAddress.selector.revertWith();\n        spotOracle = IPriceOracle(spotOracle_);\n        emit SpotOracleSet(spotOracle_);\n    }"
  ],
  "RootPriceOracle.setPythOracle": [
    "function setPythOracle(address pythOracle_) external onlyRole(MANAGER_ROLE) {\n        if (pythOracle_ == address(0)) ZeroAddress.selector.revertWith();\n        pythOracle = IPriceOracle(pythOracle_);\n        emit PythOracleSet(pythOracle_);\n    }"
  ],
  "RootPriceOracle.getPrice": [
    "function getPrice(address asset) external view returns (Data memory data) {\n        (bool pythAvailable, bool spotAvailable) = _getAssetAvailability(asset);\n        if (!pythAvailable) {\n            UnreliablePrice.selector.revertWith();\n        }\n        if (!spotAvailable) {\n            return pythOracle.getPrice(asset);\n        }\n        return _selectLargestDeviation(pythOracle.getPrice(asset), spotOracle.getPrice(asset));\n    }"
  ],
  "RootPriceOracle.getPriceUnsafe": [
    "function getPriceUnsafe(address asset) external view returns (Data memory data) {\n        (bool pythAvailable, bool spotAvailable) = _getAssetAvailability(asset);\n        if (!pythAvailable) {\n            UnreliablePrice.selector.revertWith();\n        }\n        if (!spotAvailable) {\n            return pythOracle.getPriceUnsafe(asset);\n        }\n        return _selectLargestDeviation(pythOracle.getPriceUnsafe(asset), spotOracle.getPriceUnsafe(asset));\n    }"
  ],
  "RootPriceOracle.getPriceNoOlderThan": [
    "function getPriceNoOlderThan(address asset, uint256 age) external view returns (Data memory data) {\n        (bool pythAvailable, bool spotAvailable) = _getAssetAvailability(asset);\n        if (!pythAvailable) {\n            UnreliablePrice.selector.revertWith();\n        }\n        if (!spotAvailable) {\n            return pythOracle.getPriceNoOlderThan(asset, age);\n        }\n        return _selectLargestDeviation(\n            pythOracle.getPriceNoOlderThan(asset, age), spotOracle.getPriceNoOlderThan(asset, age)\n        );\n    }"
  ],
  "RootPriceOracle.priceAvailable": [
    "function priceAvailable(address asset) external view returns (bool availability) {\n        if (address(pythOracle) != address(0)) {\n            availability = pythOracle.priceAvailable(asset);\n        }\n    }"
  ],
  "RootPriceOracle._getAssetAvailability": [
    "function _getAssetAvailability(address asset) internal view returns (bool pythAvailable, bool spotAvailable) {\n        if (address(pythOracle) != address(0)) {\n            pythAvailable = pythOracle.priceAvailable(asset);\n        }\n        if (address(spotOracle) != address(0)) {\n            spotAvailable = spotOracle.priceAvailable(asset);\n        }\n    }"
  ],
  "RootPriceOracle._selectLargestDeviation": [
    "function _selectLargestDeviation(\n        Data memory pythData,\n        Data memory spotData\n    )\n        internal\n        pure\n        returns (Data memory data)\n    {\n        if (spotData.price > WAD) {\n            spotData.price = WAD;\n        }\n        uint256 absSpotDeviation = spotData.price >= WAD ? spotData.price - WAD : WAD - spotData.price;\n        uint256 absPythDeviation = pythData.price >= WAD ? pythData.price - WAD : WAD - pythData.price;\n        data = absSpotDeviation > absPythDeviation ? spotData : pythData;\n    }"
  ],
  "IPriceOracle.getPrice": [
    "function getPrice(address asset) external view returns (Data memory data);"
  ],
  "IPriceOracle.getPriceUnsafe": [
    "function getPriceUnsafe(address asset) external view returns (Data memory data);"
  ],
  "IPriceOracle.getPriceNoOlderThan": [
    "function getPriceNoOlderThan(address asset, uint256 age) external view returns (Data memory data);"
  ],
  "IPriceOracle.priceAvailable": [
    "function priceAvailable(address asset) external view returns (bool);"
  ],
  "PythPriceOracle.initialize": [
    "function initialize(address governance_) external initializer {\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __PriceOracle_init_unchained(governance_);\n    }"
  ],
  "PythPriceOracle.__PriceOracle_init_unchained": [
    "function __PriceOracle_init_unchained(address governance_) internal onlyInitializing {\n        if (governance_ == address(0)) ZeroAddress.selector.revertWith();\n        _grantRole(DEFAULT_ADMIN_ROLE, governance_);\n    }"
  ],
  "PythPriceOracle._authorizeUpgrade": [
    "function _authorizeUpgrade(address newImplementation) internal virtual override {\n        newImplementation;\n        _checkRole(DEFAULT_ADMIN_ROLE);\n    }"
  ],
  "PythPriceOracle.setPythSource": [
    "function setPythSource(address pythOracle_) external {\n        _checkRole(DEFAULT_ADMIN_ROLE);\n        if (pythOracle_ == address(0)) ZeroAddress.selector.revertWith();\n        pyth = IPyth(pythOracle_);\n        emit OracleChanged(pythOracle_);\n    }"
  ],
  "PythPriceOracle.setPriceFeed": [
    "function setPriceFeed(address asset, bytes32 feed) external {\n        _checkRole(MANAGER_ROLE);\n        if (asset == address(0)) ZeroAddress.selector.revertWith();\n        if (feed == bytes32(0)) ZeroFeed.selector.revertWith();\n        feeds[asset] = feed;\n        getPrice(asset);\n        emit PriceFeedChanged(asset, feed);\n    }"
  ],
  "PythPriceOracle._wrapData": [
    "function _wrapData(PythStructs.Price memory response) internal pure returns (IPriceOracle.Data memory) {\n        return IPriceOracle.Data({\n            price: PythUtils.convertToUint(response.price, response.expo, 18),\n            publishTime: response.publishTime\n        });\n    }"
  ],
  "PythPriceOracle.getPrice": [
    "function getPrice(address asset) public view returns (Data memory data) {\n        if (!_pythAndFeedAreSet(asset)) {\n            UnavailableData.selector.revertWith(asset);\n        }\n        PythStructs.Price memory price = pyth.getPrice(feeds[asset]);\n        return _wrapData(price);\n    }"
  ],
  "PythPriceOracle.getPriceUnsafe": [
    "function getPriceUnsafe(address asset) public view returns (Data memory data) {\n        if (!_pythAndFeedAreSet(asset)) {\n            UnavailableData.selector.revertWith(asset);\n        }\n        PythStructs.Price memory price = pyth.getPriceUnsafe(feeds[asset]);\n        return _wrapData(price);\n    }"
  ],
  "PythPriceOracle.getPriceNoOlderThan": [
    "function getPriceNoOlderThan(address asset, uint256 age) external view returns (Data memory data) {\n        if (!_pythAndFeedAreSet(asset)) {\n            UnavailableData.selector.revertWith(asset);\n        }\n        PythStructs.Price memory price = pyth.getPriceNoOlderThan(feeds[asset], age);\n        return _wrapData(price);\n    }"
  ],
  "PythPriceOracle.priceAvailable": [
    "function priceAvailable(address asset) external view returns (bool) {\n        if (!_pythAndFeedAreSet(asset)) {\n            return false;\n        }\n        Data memory data = getPriceUnsafe(asset);\n        return data.publishTime != 0;\n    }"
  ],
  "PythPriceOracle._pythAndFeedAreSet": [
    "function _pythAndFeedAreSet(address asset) internal view returns (bool) {\n        if (address(pyth) == address(0)) {\n            return false;\n        }\n        if (feeds[asset] == bytes32(0)) {\n            return false;\n        }\n        return true;\n    }"
  ]
}